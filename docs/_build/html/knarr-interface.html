

<!DOCTYPE html>
<html class="writer-html5" lang="en" >
<head>
  <meta charset="utf-8" />
  
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  
  <title>KNARR interface &mdash; Ash 0.1 documentation</title>
  

  
  <link rel="stylesheet" href="_static/css/theme.css" type="text/css" />
  <link rel="stylesheet" href="_static/pygments.css" type="text/css" />
  <link rel="stylesheet" href="_static/my_theme.css" type="text/css" />

  
  

  
  

  

  
  <!--[if lt IE 9]>
    <script src="_static/js/html5shiv.min.js"></script>
  <![endif]-->
  
    
      <script type="text/javascript" id="documentation_options" data-url_root="./" src="_static/documentation_options.js"></script>
        <script src="_static/jquery.js"></script>
        <script src="_static/underscore.js"></script>
        <script src="_static/doctools.js"></script>
    
    <script type="text/javascript" src="_static/js/theme.js"></script>

    
    <link rel="index" title="Index" href="genindex.html" />
    <link rel="search" title="Search" href="search.html" />
    <link rel="next" title="OpenMM interface" href="OpenMM-interface.html" />
    <link rel="prev" title="geomeTRIC interface" href="geomeTRIC-interface.html" /> 
</head>

<body class="wy-body-for-nav">

   
  <div class="wy-grid-for-nav">
    
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search"  style="background: white" >
          

          
            <a href="index.html" class="icon icon-home"> Ash
          

          
            
            <img src="_static/ash-simple-logo-letterbig.png" class="logo" alt="Logo"/>
          
          </a>

          
            
            
              <div class="version">
                0.1
              </div>
            
          

          
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>

          
        </div>

        
        <div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="main navigation">
          
            
            
              
            
            
              <p class="caption"><span class="caption-text">ASH</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="About.html">About ASH</a></li>
<li class="toctree-l1"><a class="reference internal" href="setup.html">Setup</a></li>
<li class="toctree-l1"><a class="reference internal" href="basics.html">Basic usage</a></li>
<li class="toctree-l1"><a class="reference internal" href="basic-examples.html">Basic examples</a></li>
<li class="toctree-l1"><a class="reference internal" href="ash_program_philosophy.html">ASH Program Philosophy</a></li>
<li class="toctree-l1"><a class="reference internal" href="coordinate-input.html">Coordinates and fragments</a></li>
<li class="toctree-l1"><a class="reference internal" href="parallelization.html">Parallelization in ASH</a></li>
<li class="toctree-l1"><a class="reference internal" href="QM-interfaces.html">QM Interfaces</a></li>
<li class="toctree-l1"><a class="reference internal" href="MM-interfaces.html">MM Interfaces</a></li>
</ul>
<p class="caption"><span class="caption-text">Jobtypes</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="job-types.html">Job Types</a></li>
<li class="toctree-l1"><a class="reference internal" href="singlepoint.html">Singlepoint</a></li>
<li class="toctree-l1"><a class="reference internal" href="module_freq.html">Frequency calculation</a></li>
<li class="toctree-l1"><a class="reference internal" href="module_dynamics.html">Molecular dynamics</a></li>
<li class="toctree-l1"><a class="reference internal" href="neb.html">Nudged Elastic Band Method</a></li>
<li class="toctree-l1"><a class="reference internal" href="surfacescan.html">Surface Scans</a></li>
</ul>
<p class="caption"><span class="caption-text">Modules</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="module_QM-MM.html">QM/MM Theory</a></li>
<li class="toctree-l1"><a class="reference internal" href="module_benchmarking.html">Benchmarking in ASH</a></li>
<li class="toctree-l1"><a class="reference internal" href="module_workflows.html">Workflows</a></li>
<li class="toctree-l1"><a class="reference internal" href="module_highlevel_workflows.html">Highlevel workflows</a></li>
<li class="toctree-l1"><a class="reference internal" href="module_molcrys.html">MOLCRYS: Automatic QM/MM for Molecular Crystals</a></li>
<li class="toctree-l1"><a class="reference internal" href="module_PES.html">PES: PhotoElectron/PhotoEmission Spectrum</a></li>
<li class="toctree-l1"><a class="reference internal" href="module_plotting.html">Plotting</a></li>
</ul>
<p class="caption"><span class="caption-text">Interfaces</span></p>
<ul class="current">
<li class="toctree-l1"><a class="reference internal" href="ORCA-interface.html">ORCA interface</a></li>
<li class="toctree-l1"><a class="reference internal" href="xTB-interface.html">xTB interface</a></li>
<li class="toctree-l1"><a class="reference internal" href="MRCC-interface.html">MRCC interface</a></li>
<li class="toctree-l1"><a class="reference internal" href="CFour-interface.html">CFour interface</a></li>
<li class="toctree-l1"><a class="reference internal" href="Dalton-interface.html">Dalton interface</a></li>
<li class="toctree-l1"><a class="reference internal" href="PySCF-interface.html">PySCF interface</a></li>
<li class="toctree-l1"><a class="reference internal" href="Psi4-interface.html">Psi4 interface</a></li>
<li class="toctree-l1"><a class="reference internal" href="crest-interface.html">CREST interface</a></li>
<li class="toctree-l1"><a class="reference internal" href="geomeTRIC-interface.html">geomeTRIC interface</a></li>
<li class="toctree-l1 current"><a class="current reference internal" href="#">KNARR interface</a><ul>
<li class="toctree-l2"><a class="reference internal" href="#recommendations-and-how-to-use">Recommendations and how to use</a></li>
<li class="toctree-l2"><a class="reference internal" href="#examples">Examples</a></li>
<li class="toctree-l2"><a class="reference internal" href="#controlling-printout">Controlling printout</a></li>
<li class="toctree-l2"><a class="reference internal" href="#controlling-guess-orbitals-during-scf-of-theory-level">Controlling guess orbitals during SCF of Theory level</a></li>
<li class="toctree-l2"><a class="reference internal" href="#controlling-convergence">Controlling convergence</a></li>
<li class="toctree-l2"><a class="reference internal" href="#free-end-neb-calculations">Free-end NEB calculations</a></li>
<li class="toctree-l2"><a class="reference internal" href="#neb-on-systems-with-an-active-region-e-g-qm-mm">NEB on systems with an active region (e.g. QM/MM)</a></li>
<li class="toctree-l2"><a class="reference internal" href="#parallelization">Parallelization</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="OpenMM-interface.html">OpenMM interface</a></li>
</ul>
<p class="caption"><span class="caption-text">Tutorials</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="Explicit-solvation.html">Explicit solvation (small molecule)</a></li>
<li class="toctree-l1"><a class="reference internal" href="Metalloprotein-I.html">Metalloprotein tutorial I: Rubredoxin</a></li>
<li class="toctree-l1"><a class="reference internal" href="Metalloprotein-II.html">Metalloprotein tutorial II: Ferredoxin</a></li>
<li class="toctree-l1"><a class="reference internal" href="QM-MM-protein.html">QM/MM on a protein</a></li>
<li class="toctree-l1"><a class="reference internal" href="workflows-examples.html">Workflow examples in ASH</a></li>
<li class="toctree-l1"><a class="reference internal" href="Highlevel_CC_CBS_workflows.html">Tutorial: High-level CCSD(T)/CBS workflows</a></li>
</ul>
<p class="caption"><span class="caption-text">Tools</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="coordinate-tools.html">Coordinates and fragment tools</a></li>
</ul>

            
          
        </div>
        
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap">

      
      <nav class="wy-nav-top" aria-label="top navigation">
        
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="index.html">Ash</a>
        
      </nav>


      <div class="wy-nav-content">
        
        <div class="rst-content">
        
          

















<div role="navigation" aria-label="breadcrumbs navigation">

  <ul class="wy-breadcrumbs">
    
      <li><a href="index.html" class="icon icon-home"></a> &raquo;</li>
        
      <li>KNARR interface</li>
    
    
      <li class="wy-breadcrumbs-aside">
        
          
            <a href="_sources/knarr-interface.rst.txt" rel="nofollow"> View page source</a>
          
        
      </li>
    
  </ul>

  
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
            
  <div class="section" id="knarr-interface">
<h1>KNARR interface<a class="headerlink" href="#knarr-interface" title="Permalink to this headline">¶</a></h1>
<p>Nudged elastic band (NEB) calculations with/without a climbing image (CI-NEB) are possible in ASH using any theory level via an interface to the state-of-the-art NEB code, KNARR code, Vilhjálmur Ásgeirsson.
This NEB code uses energy-weighted springs (instead of a single spring constant for all images), together with a global L-BFGS optimizer that results in a greatly improved NEB algorithm for molecular systems.
The Knarr implementation predates the ORCA implementation but is overall very similar to the one described there:
V. Ásgeirsson, B. Birgisson, R. Bjornsson, U. Becker, F. Neese, C: Riplinger,  H. Jónsson, J. Chem. Theory Comput. 2021,17, 4929–4945.
DOI: 10.1021/acs.jctc.1c00462</p>
<p>Note that NEB-TS is not yet available.</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="k">def</span> <span class="nf">NEB</span><span class="p">(</span><span class="n">reactant</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">product</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">theory</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">images</span><span class="o">=</span><span class="mi">8</span><span class="p">,</span> <span class="n">CI</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">free_end</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
        <span class="n">conv_type</span><span class="o">=</span><span class="s2">&quot;ALL&quot;</span><span class="p">,</span> <span class="n">tol_scale</span><span class="o">=</span><span class="mi">10</span><span class="p">,</span> <span class="n">tol_max_fci</span><span class="o">=</span><span class="mf">0.026</span><span class="p">,</span> <span class="n">tol_rms_fci</span><span class="o">=</span><span class="mf">0.013</span><span class="p">,</span> <span class="n">tol_max_f</span><span class="o">=</span><span class="mf">0.26</span><span class="p">,</span> <span class="n">tol_rms_f</span><span class="o">=</span><span class="mf">0.13</span><span class="p">,</span>
        <span class="n">tol_turn_on_ci</span><span class="o">=</span><span class="mf">1.0</span><span class="p">,</span>  <span class="n">runmode</span><span class="o">=</span><span class="s1">&#39;serial&#39;</span><span class="p">,</span> <span class="n">numcores</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span>
        <span class="n">charge</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">mult</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span><span class="n">printlevel</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">ActiveRegion</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">actatoms</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
        <span class="n">interpolation</span><span class="o">=</span><span class="s2">&quot;IDPP&quot;</span><span class="p">,</span> <span class="n">idpp_maxiter</span><span class="o">=</span><span class="mi">300</span><span class="p">,</span>
        <span class="n">restart_file</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">TS_guess_file</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">mofilesdir</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
</pre></div>
</div>
<table class="colwidths-given docutils align-default">
<colgroup>
<col style="width: 14%" />
<col style="width: 14%" />
<col style="width: 14%" />
<col style="width: 57%" />
</colgroup>
<thead>
<tr class="row-odd"><th class="head"><p>Keyword</p></th>
<th class="head"><p>Type</p></th>
<th class="head"><p>Default value</p></th>
<th class="head"><p>Details</p></th>
</tr>
</thead>
<tbody>
<tr class="row-even"><td><p><code class="docutils literal notranslate"><span class="pre">reactant</span></code></p></td>
<td><p>ASH Fragment</p></td>
<td><p>None</p></td>
<td><p>An ASH fragment for the reactant. Geometry should ideally be previously optimized.</p></td>
</tr>
<tr class="row-odd"><td><p><code class="docutils literal notranslate"><span class="pre">product</span></code></p></td>
<td><p>ASH Fragment</p></td>
<td><p>None</p></td>
<td><p>An ASH fragment for the product. Geometry should ideally be previously optimized.</p></td>
</tr>
<tr class="row-even"><td><p><code class="docutils literal notranslate"><span class="pre">theory</span></code></p></td>
<td><p>ASH THeory</p></td>
<td><p>None</p></td>
<td><p>An ASH Theory. This will be used to supply energy+gradient information for each image during the NEB.</p></td>
</tr>
<tr class="row-odd"><td><p><code class="docutils literal notranslate"><span class="pre">images</span></code></p></td>
<td><p>integer</p></td>
<td><p>8</p></td>
<td><p>The number of images to use during the NEB. For free_end=False (recommended) this means that this number of intermediate images will be active and calculated. For free_end=True, the reactant and product images will also be included i.e. total_images = images+2</p></td>
</tr>
<tr class="row-even"><td><p><code class="docutils literal notranslate"><span class="pre">interpolation</span></code></p></td>
<td><p>string</p></td>
<td><p>‘IDPP’</p></td>
<td><p>The type of interpolation used. Default: ‘IDPP’. Other options: ‘linear’</p></td>
</tr>
<tr class="row-odd"><td><p><code class="docutils literal notranslate"><span class="pre">CI</span></code></p></td>
<td><p>Boolean</p></td>
<td><p>True</p></td>
<td><p>Whether to use a climbing image or not during NEB. CI is always recommended.</p></td>
</tr>
<tr class="row-even"><td><p><code class="docutils literal notranslate"><span class="pre">free_end</span></code></p></td>
<td><p>Boolean</p></td>
<td><p>False</p></td>
<td><p>Whether initial images are free or frozen. Warning: the number of active images will be images+2 when this is True.</p></td>
</tr>
<tr class="row-odd"><td><p><code class="docutils literal notranslate"><span class="pre">restart_file</span></code></p></td>
<td><p>‘string’</p></td>
<td><p>None</p></td>
<td><p>Name of restart-file (XYZ-file) to use as initial guess path instead of IDPP/linear.</p></td>
</tr>
<tr class="row-even"><td><p><code class="docutils literal notranslate"><span class="pre">TS_guess_file</span></code></p></td>
<td><p>‘string’</p></td>
<td><p>None</p></td>
<td><p>Name of XYZ-file containing a guess for the saddlepoint(“TS”). The TS guess will be used during the interpolation step to provide a better guess for the overall guess-path.</p></td>
</tr>
<tr class="row-odd"><td><p><code class="docutils literal notranslate"><span class="pre">mofilesdir</span></code></p></td>
<td><p>‘string’</p></td>
<td><p>None</p></td>
<td><p>Path (absolute or relative path) to a directory with MO-files to be used as guess orbitals in the first NEB iterations. For ORCATheory these should be GBW-files named: “current_image0.gbw” etc.</p></td>
</tr>
<tr class="row-even"><td><p><code class="docutils literal notranslate"><span class="pre">conv_type</span></code></p></td>
<td><p>string</p></td>
<td><p>‘ALL’</p></td>
<td><p>Convergence type. Options: ‘ALL’, ‘CIONLY’.</p></td>
</tr>
<tr class="row-odd"><td><p><code class="docutils literal notranslate"><span class="pre">tol_scale</span></code></p></td>
<td><p>float</p></td>
<td><p>10</p></td>
<td><p>Scaling tolerance during NEB. Units: eV/Å</p></td>
</tr>
<tr class="row-even"><td><p><code class="docutils literal notranslate"><span class="pre">tol_max_fci</span></code></p></td>
<td><p>float</p></td>
<td><p>0.026</p></td>
<td><p>The Max Force convergence tolerance for the Climbing IMage. Units: eV/Å</p></td>
</tr>
<tr class="row-odd"><td><p><code class="docutils literal notranslate"><span class="pre">tol_rms_fci</span></code></p></td>
<td><p>float</p></td>
<td><p>0.013</p></td>
<td><p>The RMS Force convergence tolerance for the Climbing IMage. Units: eV/Å</p></td>
</tr>
<tr class="row-even"><td><p><code class="docutils literal notranslate"><span class="pre">tol_max_f</span></code></p></td>
<td><p>float</p></td>
<td><p>0.26</p></td>
<td><p>The Max Force convergence tolerance for all other images except CI. Units: eV/Å</p></td>
</tr>
<tr class="row-odd"><td><p><code class="docutils literal notranslate"><span class="pre">tol_rms_f</span></code></p></td>
<td><p>float</p></td>
<td><p>0.13</p></td>
<td><p>The RMS Force convergence tolerance for all other images except CI. Units: eV/Å</p></td>
</tr>
<tr class="row-even"><td><p><code class="docutils literal notranslate"><span class="pre">tol_turn_on_ci</span></code></p></td>
<td><p>float</p></td>
<td><p>1.0</p></td>
<td><p>The threshold on Max Force for turning on the climbing image. Units: eV/Å</p></td>
</tr>
<tr class="row-odd"><td><p><code class="docutils literal notranslate"><span class="pre">ActiveRegion</span></code></p></td>
<td><p>Boolean</p></td>
<td><p>False</p></td>
<td><p>Whether to use an Active Region during the NEB job. This requires setting the number of active atoms (actatoms list) below.</p></td>
</tr>
<tr class="row-even"><td><p><code class="docutils literal notranslate"><span class="pre">actatoms</span></code></p></td>
<td><p>list</p></td>
<td><p>None</p></td>
<td><p>List of atom indices that are active during the NEB job. All other atoms are frozen.</p></td>
</tr>
<tr class="row-odd"><td><p><code class="docutils literal notranslate"><span class="pre">runmode</span></code></p></td>
<td><p>string</p></td>
<td><p>‘serial’</p></td>
<td><p>Runmode: ‘serial’ or ‘parallel’. Runmode ‘parallel’ requires setting numcores keyword below.</p></td>
</tr>
<tr class="row-even"><td><p><code class="docutils literal notranslate"><span class="pre">numcores</span></code></p></td>
<td><p>integer</p></td>
<td><p>1</p></td>
<td><p>Numcores of cores to use in a parallel NEB job. Recommended: use same number of cores as there are active images.</p></td>
</tr>
<tr class="row-odd"><td><p><code class="docutils literal notranslate"><span class="pre">printlevel</span></code></p></td>
<td><p>integer</p></td>
<td><p>0</p></td>
<td><p>The printlevel to use in NEB calculations. This same printlevel is enforced in the Theory object. Change to 1,2 or 3 to get more printing.</p></td>
</tr>
<tr class="row-even"><td><p><code class="docutils literal notranslate"><span class="pre">idpp_maxiter</span></code></p></td>
<td><p>integer</p></td>
<td><p>300</p></td>
<td><p>Maximum number of iterations to use in the IDPP guess path calculations</p></td>
</tr>
<tr class="row-odd"><td><p><code class="docutils literal notranslate"><span class="pre">charge</span></code></p></td>
<td><p>integer</p></td>
<td><p>None</p></td>
<td><p>Optional specification of the charge of the system (if QM).</p></td>
</tr>
<tr class="row-even"><td><p><code class="docutils literal notranslate"><span class="pre">mult</span></code></p></td>
<td><p>integer</p></td>
<td><p>None</p></td>
<td><p>Optional specification of the spin multiplicity of the system (if QM).</p></td>
</tr>
</tbody>
</table>
<div class="section" id="recommendations-and-how-to-use">
<h2>Recommendations and how to use<a class="headerlink" href="#recommendations-and-how-to-use" title="Permalink to this headline">¶</a></h2>
<ul class="simple">
<li><p>Generally, the default settings are reasonably reliable and need not be touched. The number of images is the most important parameter.</p></li>
<li><p>CI-NEB is almost always desired. A NEB job without CI, gives only a crude estimate of the barrier.</p></li>
<li><p>Frozen endpoints (free_end=False, i.e. reactant and product frozen) is usually recommended (more efficient). Reactant and product should have been previously optimized.</p></li>
<li><p>If you want to explore active endpoints (free_end=True), note that the number of active images will be images+2,</p></li>
<li><p>The most important parameter is the number of images. Few images will result in fewer energy+gradient calculations but may hinder convergence. Many images will give a high resolution of the minimum energy path, will have fewer convergence problems but will result in an expensive calculation. A good number is usually 5-11 or so.</p></li>
<li><p>In runmode = ‘parallel’ you should generally choose the number of active images to be equal to the number of CPU cores provided to NEB.</p></li>
<li><p>If you activate parallelization of the theory level also, this will be the number of cores used per image. So if you do ORCATheory(…numcores=2) and NEB(…images=8,numcores=8) ASH will be attempting to use 2x8 = 16 cores.</p></li>
<li><p>When a partially converged NEB path reveals that there probably is an intermediate inbetween, it is best to cancel the calculation and split the job into 2 jobs, i.e. start a new job from reactant to intermediate and another from intermediate to product. A CI-NEB job would only converge to the higher energy saddlepoint in such a case.</p></li>
<li><p>It can be a good idea to do an initial NEB from a lower level of theory (e.g. xTB) before doing the higher level of theory (DFT). Use restart_file option to read in lower-level MEP as guess.</p></li>
<li><p>If you already know approximately what the saddlepoint geometry should look like you can provide such a geometry using the TS_guess_file option. The geometry will be used during the interpolation to provide a more accurate guess path. This could also be a previously obtained saddlepoint at another level of theory.</p></li>
<li><p>If a CI-NEB calculation converges, the saddlepoint geometry can be confirmed as a saddlepoint via a NumFreq job. NEB returns an ASH Fragment of the saddlepoint geometry as well as an XYZ-file.</p></li>
<li><p>Any ASH Theory level can in principle be used (although only ORCA and xTB have been tested). In practice you want to use a QM method and code with an analytical gradient available.</p></li>
</ul>
</div>
<div class="section" id="examples">
<h2>Examples<a class="headerlink" href="#examples" title="Permalink to this headline">¶</a></h2>
<p><strong>8-image NEB calculation at the XTB level of theory (Theory parallelization):</strong></p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="kn">from</span> <span class="nn">ash</span> <span class="kn">import</span> <span class="o">*</span>

<span class="n">numcores</span><span class="o">=</span><span class="mi">8</span>

<span class="c1">################################################</span>
<span class="c1"># Defining reactant and product ASH fragments</span>
<span class="c1">#################################################</span>
<span class="n">react</span><span class="o">=</span><span class="n">Fragment</span><span class="p">(</span><span class="n">xyzfile</span><span class="o">=</span><span class="s2">&quot;react.xyz&quot;</span><span class="p">,</span> <span class="n">charge</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">mult</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
<span class="n">prod</span><span class="o">=</span><span class="n">Fragment</span><span class="p">(</span><span class="n">xyzfile</span><span class="o">=</span><span class="s2">&quot;prod.xyz&quot;</span><span class="p">,</span> <span class="n">charge</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">mult</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>

<span class="c1">#Theory to use for NEB. Setting number of cores for xTB.</span>
<span class="n">xtbcalc</span> <span class="o">=</span> <span class="n">xTBTheory</span><span class="p">(</span><span class="n">xtbmethod</span><span class="o">=</span><span class="s1">&#39;GFN2&#39;</span><span class="p">,</span> <span class="n">runmode</span><span class="o">=</span><span class="s1">&#39;library&#39;</span><span class="p">,</span> <span class="n">numcores</span><span class="o">=</span><span class="n">numcores</span><span class="p">)</span>

<span class="c1">#Run NEB to find saddlepoint. Returns saddlepoint as ASH fragment</span>
<span class="n">SP</span> <span class="o">=</span> <span class="n">NEB</span><span class="p">(</span><span class="n">reactant</span><span class="o">=</span><span class="n">react</span><span class="p">,</span> <span class="n">product</span><span class="o">=</span><span class="n">prod</span><span class="p">,</span> <span class="n">theory</span><span class="o">=</span><span class="n">xtbcalc</span><span class="p">,</span> <span class="n">images</span><span class="o">=</span><span class="mi">8</span><span class="p">)</span>

<span class="c1">#Optional NumFreq job on saddlepoint to confirm that a saddlepoint was found.</span>
<span class="n">NumFreq</span><span class="p">(</span><span class="n">theory</span><span class="o">=</span><span class="n">xtbcalc</span><span class="p">,</span> <span class="n">fragment</span><span class="o">=</span><span class="n">SP</span><span class="p">)</span>
</pre></div>
</div>
<p><strong>Restarting a calculation with user-defined path-file.</strong></p>
<p>Here, using the <em>restart_file</em> option to the NEB we read in a previous Knarr path-file (“knarr_MEP.xyz”) instead of doing the regular IDPP interpolation
This file must contain the coordinates of the same number of images (here 10) as number of images specified.
The file can come from a previously unconverged NEB calculation or perhaps a converged MEP from a calculation at another level of theory.</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="kn">from</span> <span class="nn">ash</span> <span class="kn">import</span> <span class="o">*</span>

<span class="n">numcores</span><span class="o">=</span><span class="mi">1</span>

<span class="c1">################################################</span>
<span class="c1"># Defining reactant and product ASH fragments</span>
<span class="c1">#################################################</span>
<span class="n">react</span><span class="o">=</span><span class="n">Fragment</span><span class="p">(</span><span class="n">xyzfile</span><span class="o">=</span><span class="s2">&quot;react.xyz&quot;</span><span class="p">,</span> <span class="n">charge</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">mult</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
<span class="n">prod</span><span class="o">=</span><span class="n">Fragment</span><span class="p">(</span><span class="n">xyzfile</span><span class="o">=</span><span class="s2">&quot;prod.xyz&quot;</span><span class="p">,</span> <span class="n">charge</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">mult</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>


<span class="c1">#Theory to use for NEB</span>
<span class="n">xtbcalc</span> <span class="o">=</span> <span class="n">xTBTheory</span><span class="p">(</span><span class="n">xtbmethod</span><span class="o">=</span><span class="s1">&#39;GFN2&#39;</span><span class="p">,</span> <span class="n">runmode</span><span class="o">=</span><span class="s1">&#39;library&#39;</span><span class="p">)</span>

<span class="c1">#Run NEB to find saddlepoint. Returns saddlepoint as ASH fragment</span>
<span class="n">SP</span> <span class="o">=</span> <span class="n">NEB</span><span class="p">(</span><span class="n">reactant</span><span class="o">=</span><span class="n">react</span><span class="p">,</span> <span class="n">product</span><span class="o">=</span><span class="n">prod</span><span class="p">,</span> <span class="n">theory</span><span class="o">=</span><span class="n">xtbcalc</span><span class="p">,</span> <span class="n">images</span><span class="o">=</span><span class="mi">10</span><span class="p">,</span> <span class="n">restart_file</span><span class="o">=</span><span class="s2">&quot;knarr_MEP.xyz&quot;</span><span class="p">)</span>
</pre></div>
</div>
<p>** A calculation with user-defined guess for the saddlepoint.**</p>
<p>Here, using the <em>TS_guess_file</em> option. This will influence the initial interpolation path generation by interpolating between reactant and guess_TS structure and guess_TS structure and product.</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="kn">from</span> <span class="nn">ash</span> <span class="kn">import</span> <span class="o">*</span>

<span class="n">numcores</span><span class="o">=</span><span class="mi">1</span>

<span class="c1">################################################</span>
<span class="c1"># Defining reactant and product ASH fragments</span>
<span class="c1">#################################################</span>
<span class="n">react</span><span class="o">=</span><span class="n">Fragment</span><span class="p">(</span><span class="n">xyzfile</span><span class="o">=</span><span class="s2">&quot;react.xyz&quot;</span><span class="p">,</span> <span class="n">charge</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">mult</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
<span class="n">prod</span><span class="o">=</span><span class="n">Fragment</span><span class="p">(</span><span class="n">xyzfile</span><span class="o">=</span><span class="s2">&quot;prod.xyz&quot;</span><span class="p">,</span> <span class="n">charge</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">mult</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>

<span class="c1">#Theory to use for NEB</span>
<span class="n">xtbcalc</span> <span class="o">=</span> <span class="n">xTBTheory</span><span class="p">(</span><span class="n">xtbmethod</span><span class="o">=</span><span class="s1">&#39;GFN2&#39;</span><span class="p">,</span> <span class="n">runmode</span><span class="o">=</span><span class="s1">&#39;library&#39;</span><span class="p">)</span>

<span class="c1">#Run NEB to find saddlepoint. Returns saddlepoint as ASH fragment</span>
<span class="n">SP</span> <span class="o">=</span> <span class="n">NEB</span><span class="p">(</span><span class="n">reactant</span><span class="o">=</span><span class="n">react</span><span class="p">,</span> <span class="n">product</span><span class="o">=</span><span class="n">prod</span><span class="p">,</span> <span class="n">theory</span><span class="o">=</span><span class="n">xtbcalc</span><span class="p">,</span> <span class="n">images</span><span class="o">=</span><span class="mi">10</span><span class="p">,</span> <span class="n">TS_guess_file</span><span class="o">=</span><span class="s2">&quot;guess_TS_geometry.xyz&quot;</span><span class="p">)</span>
</pre></div>
</div>
</div>
<div class="section" id="controlling-printout">
<h2>Controlling printout<a class="headerlink" href="#controlling-printout" title="Permalink to this headline">¶</a></h2>
<p>During a NEB calculation the theory code is called multiple times to calculate the energy and gradient.
As the printout can become excessive (especially if using a QMMMTheory object) it is usually desirable to reduce printout considerably for NEB calculations.
This is performed by setting the printlevel in the NEB calculation as a keyword argument.
The NEB printlevel is then used to set the printlevel in the Theory objects.
The default printlevel is 0 (barely any output from other modules) but this can be increased to 1,2 or 3 to get more output, both from the NEB function and the Theory level etc.
Printlevel 1 is useful for getting more useful information from the NEB module (especially regarding guess orbital logic) as well as slightly more information from the Theory object. Printlevel 2 will probably give too much output in general but can be useful for diagnostic purposes.</p>
<p>Example:</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="c1">#Run NEB to find saddlepoint. Returns saddlepoint as ASH fragment</span>
<span class="n">SP</span> <span class="o">=</span> <span class="n">NEB</span><span class="p">(</span><span class="n">reactant</span><span class="o">=</span><span class="n">react</span><span class="p">,</span> <span class="n">product</span><span class="o">=</span><span class="n">prod</span><span class="p">,</span> <span class="n">theory</span><span class="o">=</span><span class="n">xtbcalc</span><span class="p">,</span> <span class="n">images</span><span class="o">=</span><span class="mi">10</span><span class="p">,</span> <span class="n">printlevel</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
</pre></div>
</div>
</div>
<div class="section" id="controlling-guess-orbitals-during-scf-of-theory-level">
<h2>Controlling guess orbitals during SCF of Theory level<a class="headerlink" href="#controlling-guess-orbitals-during-scf-of-theory-level" title="Permalink to this headline">¶</a></h2>
<p>During the NEB job the Theory level object is called multiple times using each iteration. The Theory level object will handle what guess orbitals are used during this step and you can modify the Theory object as desired
(e.g. for ORCATheory you can change autostart and moreadfile keywords as desired).</p>
<p>By default, for e.g. ORCATheory, the first calculation in the NEB job (NEB iteration -1) will be on the reactant. ORCA will in this case use brand-new guess orbitals (from PModel guess typically).
Once converged, the orca.gbw file will be copied and stored as current_image0.gbw by the NEB module.
Next calculation on the product will use the previous orca.gbw file (from reactant) since ORCA will by default try to read orbitals from that file (since the inputfile has the same basename) but once ORCA is finished we will store the file as e.g. current_image11.gbw
This is repeated for intermediate images: image1, image2, …, image10.gbw in NEB iteration 0.
However, in the next NEB iterations, the code will find and use current_image1.gbw for image no. 1 etc. since these files have been stored. These files will be updated during the job, ensuring that each image has converged image-specific orbitals from the last iteration available.</p>
<p>In order to see detailed printout for what is going on w.r.t. ORCA GBW-file book-keeping during the NEB job, set the NEB printlevel to 1.</p>
<p>For parallel NEB calculations, things will differ slightly.</p>
<p>Generally this behaviour works well as previously converged orbitals, specific to each image are being used.
If you require even more control over which orbitals should be used there are a few options.</p>
<p><strong>1. Reading in a single initial guess orbital-file (ORCATheory) :</strong></p>
<p>By doing ORCATheory(…moreadfile=”test.gbw”), ORCA will read in orbitals from file “test.gbw” (make sure to copy file “test.gbw” to scratch or provide full path) in the first calculation by NEB(reactant calculation).
This option is primarily useful if the system is tough to converge (e.g. a BS-DFT job on a spin-coupled system).
Note: By default, the moreadfile option is turned off in the ORCATheory object after that so if you want to enforce moreadfile behaviour for every calculation during the NEB job, you could do: ORCATheory(…moreadfile=”test.gbw”, moreadfile_always=True).
This is probably unlikely to be useful though.</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="kn">from</span> <span class="nn">ash</span> <span class="kn">import</span> <span class="o">*</span>

<span class="n">numcores</span><span class="o">=</span><span class="mi">1</span>
<span class="c1">#SN2 reaction</span>
<span class="n">Reactant</span><span class="o">=</span><span class="n">Fragment</span><span class="p">(</span><span class="n">xyzfile</span><span class="o">=</span><span class="s2">&quot;react.xyz&quot;</span><span class="p">,</span> <span class="n">charge</span><span class="o">=-</span><span class="mi">1</span><span class="p">,</span> <span class="n">mult</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
<span class="n">Product</span><span class="o">=</span><span class="n">Fragment</span><span class="p">(</span><span class="n">xyzfile</span><span class="o">=</span><span class="s2">&quot;prod.xyz&quot;</span><span class="p">,</span><span class="n">charge</span><span class="o">=-</span><span class="mi">1</span><span class="p">,</span> <span class="n">mult</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>

<span class="c1">#Calculator object without frag</span>
<span class="n">calc</span> <span class="o">=</span> <span class="n">ORCATheory</span><span class="p">(</span><span class="n">orcasimpleinput</span><span class="o">=</span><span class="s2">&quot;!r2scan-3c tightscf CPCM&quot;</span><span class="p">,</span> <span class="n">numcores</span><span class="o">=</span><span class="n">numcores</span><span class="p">,</span> <span class="n">moreadfile</span><span class="o">=</span><span class="s2">&quot;test.gbw&quot;</span><span class="p">)</span>

<span class="n">SP</span> <span class="o">=</span> <span class="n">NEB</span><span class="p">(</span><span class="n">reactant</span><span class="o">=</span><span class="n">Reactant</span><span class="p">,</span> <span class="n">product</span><span class="o">=</span><span class="n">Product</span><span class="p">,</span> <span class="n">theory</span><span class="o">=</span><span class="n">calc</span><span class="p">,</span> <span class="n">images</span><span class="o">=</span><span class="mi">10</span><span class="p">,</span> <span class="n">printlevel</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
</pre></div>
</div>
<p><strong>2. Reading in guess orbitals for each image separately from a directory (ORCATheory):</strong></p>
<p>A better way to control the original guess is to provide to the NEB function, a mofilesdir keyword pointing to a directory-path that contains GBW files for each image.
The directory should contain GBW files for each image and should be called:</p>
<p><em>current_image0.gbw, current_image1.gbw, current_image2.gbw, …, current_image11.gbw</em> etc.</p>
<p>This allows you more flexibility in choosing precisely what orbitals will be read in initially.</p>
<p><strong>Note:</strong> Orbitals will only be read from the mofilesdir directory in NEB-iteration -1 (first reactant and product calcs) and NEB-iteration 0 (first intermediate image calculations). In the subsequent NEB iterations, the program will use image-specific GBW files from the previous iteration.</p>
<p><strong>Note:</strong>  The mofilesdir path must either be a full path to a directory that is available to the computing node (e.g. /home/bjornsson/NEBjob1/mofilesdir or something) or a directory that is copied over to the the scratch
directory by your job-submission script.</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="kn">from</span> <span class="nn">ash</span> <span class="kn">import</span> <span class="o">*</span>

<span class="n">numcores</span><span class="o">=</span><span class="mi">1</span>
<span class="c1">#SN2 reaction</span>
<span class="n">Reactant</span><span class="o">=</span><span class="n">Fragment</span><span class="p">(</span><span class="n">xyzfile</span><span class="o">=</span><span class="s2">&quot;react.xyz&quot;</span><span class="p">,</span> <span class="n">charge</span><span class="o">=-</span><span class="mi">1</span><span class="p">,</span> <span class="n">mult</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
<span class="n">Product</span><span class="o">=</span><span class="n">Fragment</span><span class="p">(</span><span class="n">xyzfile</span><span class="o">=</span><span class="s2">&quot;prod.xyz&quot;</span><span class="p">,</span><span class="n">charge</span><span class="o">=-</span><span class="mi">1</span><span class="p">,</span> <span class="n">mult</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>

<span class="c1">#Calculator object without frag</span>
<span class="n">calc</span> <span class="o">=</span> <span class="n">ORCATheory</span><span class="p">(</span><span class="n">orcasimpleinput</span><span class="o">=</span><span class="s2">&quot;!r2scan-3c tightscf CPCM&quot;</span><span class="p">,</span> <span class="n">numcores</span><span class="o">=</span><span class="n">numcores</span><span class="p">)</span>

<span class="n">SP</span> <span class="o">=</span> <span class="n">NEB</span><span class="p">(</span><span class="n">reactant</span><span class="o">=</span><span class="n">Reactant</span><span class="p">,</span> <span class="n">product</span><span class="o">=</span><span class="n">Product</span><span class="p">,</span> <span class="n">theory</span><span class="o">=</span><span class="n">calc</span><span class="p">,</span> <span class="n">images</span><span class="o">=</span><span class="mi">10</span><span class="p">,</span> <span class="n">printlevel</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">mofilesdir</span><span class="o">=</span><span class="s2">&quot;/home/bjornsson/NEBjob1/mofiles_dir&quot;</span><span class="p">)</span>
</pre></div>
</div>
</div>
<div class="section" id="controlling-convergence">
<h2>Controlling convergence<a class="headerlink" href="#controlling-convergence" title="Permalink to this headline">¶</a></h2>
<p>NEB convergence is controlled by a number of thresholds. Note that Knarr internally utilizes units of Å (distances and coordinates), eV (energies), eV/Å (forces), eV/Å^2 (force constants).
For now, the interface requires you to specify convergence tolerances in these units as well.</p>
<p>conv_type: ‘ALL’ or ‘CIONLY’ options specifies whether the NEB job should end when all the tolerances of the images have been met (‘ALL’) or only on the CI (‘CIONLY’)
The default is ‘ALL’ and is recommended. All 4 threshold belows have to be met in this case (only the first 2 in the case of ‘CIONLY’).</p>
<p><strong>Convergence tolerances:</strong></p>
<ul class="simple">
<li><p>tol_max_fci : This tolerance (default: 0.026 eV/Å) species when the Max Force on the CI is met.</p></li>
<li><p>tol_rms_fci : This tolerance (default: 0.013 eV/Å) species when the RMS Force on the CI is met.</p></li>
<li><p>tol_max_f : This tolerance (default: 0.026 eV/Å) species when the Max Force on all other images is met.</p></li>
<li><p>tol_rms_f : This tolerance (default: 0.013 eV/Å) species when the RMS Force on all other images is met.</p></li>
</ul>
<p><strong>Other thresholds:</strong></p>
<ul class="simple">
<li><p>tol_turn_on_ci : This tolerance (default: 1.0 eV/Å on the Max Force) specifies when the CI image option should be turned on, in which one of the images will start minimizing towards a saddlepoint.</p></li>
<li><p>tol_scale  : This tolerance (default 10) specifies</p></li>
</ul>
</div>
<div class="section" id="free-end-neb-calculations">
<h2>Free-end NEB calculations<a class="headerlink" href="#free-end-neb-calculations" title="Permalink to this headline">¶</a></h2>
<p>A recommended NEB job has endpoints (reactant and product) previously optimized at the same level of theory and are then kept frozen during the NEB job.
This usually results in a more efficient NEB job as it constrains the possibilities for the minimum energy path and saddlepoint search.</p>
<p>A free_end = True option where the endpoints are also minimized during the NEB is also possible but as there are more degrees of freedom, it can be trickier to converge.
This may be a good option when the endpoints have deliberately not been minimized in an effort to explore multiple potential reaction pathways.</p>
</div>
<div class="section" id="neb-on-systems-with-an-active-region-e-g-qm-mm">
<h2>NEB on systems with an active region (e.g. QM/MM)<a class="headerlink" href="#neb-on-systems-with-an-active-region-e-g-qm-mm" title="Permalink to this headline">¶</a></h2>
<p>For large systems, e.g. a QM/MM model of a protein active site, it is possible to perform a NEB calculation of only a selected group of atoms, with other atoms being frozen during the NEB iterations.
You should set ActiveRegion=True in this case and then specify the list of active atoms by their indices via e.g. actatoms=[17,18,19,20,21,22,23,24]
As a NEB calculation is a difficult minimization problem it is advised to keep the active region as small as possible, at least to begin with. For a QM/MM job it might be a good idea to first set actatoms = qmatoms. i.e. only allow the QM atoms to move during the NEB path minimization.
Future version of the code may further allow one to use weights</p>
<p>Note: When an active region is used, the RMSD minimization for images is turned off automatically (used to superimpose images to avoid complicated NEB paths).</p>
</div>
<div class="section" id="parallelization">
<h2>Parallelization<a class="headerlink" href="#parallelization" title="Permalink to this headline">¶</a></h2>
<p>During each NEB iteration, X number of images are active and their energy+gradient needs to be calculated for each new geometry in each iteration.
As each E+G image calculation is independent from the others it is possible to utilize parallelization very effectively in a NEB job.
It is generally recommended to prioritize parallelization over images rather than the Theory level (QM parallelization never scales perfectly)
Theory parallelization is also available, however, and can be used to further speed up NEB job.</p>
<p><strong>Example: 8-image NEB calculation at the XTB level of theory (NEB parallelization):</strong></p>
<p>If you are calculating 8 images then you should set runmode=’parallel’ and use numcores=8.</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="kn">from</span> <span class="nn">ash</span> <span class="kn">import</span> <span class="o">*</span>

<span class="n">numcores</span><span class="o">=</span><span class="mi">8</span>
<span class="n">numimages</span><span class="o">=</span><span class="n">numcores</span>
<span class="c1">################################################</span>
<span class="c1"># Defining reactant and product ASH fragments</span>
<span class="c1">#################################################</span>
<span class="n">react</span><span class="o">=</span><span class="n">Fragment</span><span class="p">(</span><span class="n">xyzfile</span><span class="o">=</span><span class="s2">&quot;react.xyz&quot;</span><span class="p">,</span> <span class="n">charge</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">mult</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
<span class="n">prod</span><span class="o">=</span><span class="n">Fragment</span><span class="p">(</span><span class="n">xyzfile</span><span class="o">=</span><span class="s2">&quot;prod.xyz&quot;</span><span class="p">,</span> <span class="n">charge</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">mult</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>

<span class="c1">#Theory to use for NEB</span>
<span class="n">xtbcalc</span> <span class="o">=</span> <span class="n">xTBTheory</span><span class="p">(</span><span class="n">xtbmethod</span><span class="o">=</span><span class="s1">&#39;GFN2&#39;</span><span class="p">,</span> <span class="n">runmode</span><span class="o">=</span><span class="s1">&#39;library&#39;</span><span class="p">,</span> <span class="n">numcores</span><span class="o">=</span><span class="n">numcores</span><span class="p">)</span>

<span class="c1">#Run NEB to find saddlepoint. Returns saddlepoint as ASH fragment</span>
<span class="n">SP</span> <span class="o">=</span> <span class="n">NEB</span><span class="p">(</span><span class="n">reactant</span><span class="o">=</span><span class="n">react</span><span class="p">,</span> <span class="n">product</span><span class="o">=</span><span class="n">prod</span><span class="p">,</span> <span class="n">theory</span><span class="o">=</span><span class="n">xtbcalc</span><span class="p">,</span> <span class="n">images</span><span class="o">=</span><span class="n">numimages</span><span class="p">,</span> <span class="n">runmode</span><span class="o">=</span><span class="s1">&#39;parallel&#39;</span><span class="p">,</span> <span class="n">numcores</span><span class="o">=</span><span class="n">numcores</span><span class="p">)</span>

<span class="c1">#Optional NumFreq job on saddlepoint to confirm that a saddlepoint was found.</span>
<span class="n">NumFreq</span><span class="p">(</span><span class="n">theory</span><span class="o">=</span><span class="n">xtbcalc</span><span class="p">,</span> <span class="n">fragment</span><span class="o">=</span><span class="n">SP</span><span class="p">)</span>
</pre></div>
</div>
<p>If you have additional CPU cores available on your computing node that you would like to use to speed up an NEB job you have 2 options:</p>
<ul class="simple">
<li><p>You could increase the number of images as well as CPU cores to e.g. 16. Such a 16-image/core-job would run each NEB iteration at the same speed as the 8 image/core job but since there are more images it may facilitate convergence and locate the saddlepoint more efficiently.</p></li>
<li><p>Or you could active Theory parallelization by setting the numcores keyword for the Theory level. If you have 16 cores available on your node, you could set Theory parallelization to 2 which would result in each of the 8 images utilizing 2 CPU cores to speed up the E+G step, resulting in 16 cores being used.</p></li>
</ul>
<p><strong>Example: 16-core job using 8-image NEB parallelization + Theory parallelization:</strong></p>
<p>This NEB job would run 8 active images simultaneously (via Python multiprocessing library) while parallelizing each xTB E+G calculation by 2 cores.
This job requires 16 available CPU cores.</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="kn">from</span> <span class="nn">ash</span> <span class="kn">import</span> <span class="o">*</span>

<span class="n">numcores</span><span class="o">=</span><span class="mi">16</span> <span class="c1">#Total number of CPU cores to be used (makes sure to submit a job with this number of slots)</span>
<span class="n">numimages</span><span class="o">=</span><span class="mi">8</span> <span class="c1">#Number of images in NEB job and the number of cores available to the NEB parallelization</span>
<span class="n">cores_theory</span><span class="o">=</span><span class="n">numcores</span><span class="o">/</span><span class="n">numimages</span> <span class="c1">#Number of cores used to parallelize the Theory level</span>
<span class="c1">################################################</span>
<span class="c1"># Defining reactant and product ASH fragments</span>
<span class="c1">#################################################</span>
<span class="n">react</span><span class="o">=</span><span class="n">Fragment</span><span class="p">(</span><span class="n">xyzfile</span><span class="o">=</span><span class="s2">&quot;react.xyz&quot;</span><span class="p">,</span> <span class="n">charge</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">mult</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
<span class="n">prod</span><span class="o">=</span><span class="n">Fragment</span><span class="p">(</span><span class="n">xyzfile</span><span class="o">=</span><span class="s2">&quot;prod.xyz&quot;</span><span class="p">,</span> <span class="n">charge</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">mult</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>

<span class="c1">#Theory to use for NEB. Parallelizing</span>
<span class="n">xtbcalc</span> <span class="o">=</span> <span class="n">xTBTheory</span><span class="p">(</span><span class="n">xtbmethod</span><span class="o">=</span><span class="s1">&#39;GFN2&#39;</span><span class="p">,</span> <span class="n">runmode</span><span class="o">=</span><span class="s1">&#39;library&#39;</span><span class="p">,</span> <span class="n">numcores</span><span class="o">=</span><span class="n">cores_theory</span><span class="p">)</span>

<span class="c1">#Run NEB to find saddlepoint. Returns saddlepoint as ASH fragment</span>
<span class="n">SP</span> <span class="o">=</span> <span class="n">NEB</span><span class="p">(</span><span class="n">reactant</span><span class="o">=</span><span class="n">react</span><span class="p">,</span> <span class="n">product</span><span class="o">=</span><span class="n">prod</span><span class="p">,</span> <span class="n">theory</span><span class="o">=</span><span class="n">xtbcalc</span><span class="p">,</span> <span class="n">images</span><span class="o">=</span><span class="n">numimages</span><span class="p">,</span> <span class="n">runmode</span><span class="o">=</span><span class="s1">&#39;parallel&#39;</span><span class="p">,</span> <span class="n">numcores</span><span class="o">=</span><span class="n">numimages</span><span class="p">)</span>

<span class="c1">#Optional NumFreq job on saddlepoint to confirm that a saddlepoint was found.</span>
<span class="n">NumFreq</span><span class="p">(</span><span class="n">theory</span><span class="o">=</span><span class="n">xtbcalc</span><span class="p">,</span> <span class="n">fragment</span><span class="o">=</span><span class="n">SP</span><span class="p">)</span>
</pre></div>
</div>
</div>
</div>


           </div>
           
          </div>
          <footer>
    <div class="rst-footer-buttons" role="navigation" aria-label="footer navigation">
        <a href="OpenMM-interface.html" class="btn btn-neutral float-right" title="OpenMM interface" accesskey="n" rel="next">Next <span class="fa fa-arrow-circle-right" aria-hidden="true"></span></a>
        <a href="geomeTRIC-interface.html" class="btn btn-neutral float-left" title="geomeTRIC interface" accesskey="p" rel="prev"><span class="fa fa-arrow-circle-left" aria-hidden="true"></span> Previous</a>
    </div>

  <hr/>

  <div role="contentinfo">
    <p>
        &#169; Copyright 2020, Ragnar Bjornsson.

    </p>
  </div>
    
    
    
    Built with <a href="https://www.sphinx-doc.org/">Sphinx</a> using a
    
    <a href="https://github.com/readthedocs/sphinx_rtd_theme">theme</a>
    
    provided by <a href="https://readthedocs.org">Read the Docs</a>. 

</footer>
        </div>
      </div>

    </section>

  </div>
  

  <script type="text/javascript">
      jQuery(function () {
          SphinxRtdTheme.Navigation.enable(true);
      });
  </script>

  
  
    
    <!-- Theme Analytics -->
    <script>
    (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
      (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
      m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
    })(window,document,'script','https://www.google-analytics.com/analytics.js','ga');

    ga('create', 'UA-XXXXXXX-1', 'auto');
    
    ga('send', 'pageview');
    </script>

    
   

</body>
</html>