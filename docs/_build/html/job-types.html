

<!DOCTYPE html>
<!--[if IE 8]><html class="no-js lt-ie9" lang="en" > <![endif]-->
<!--[if gt IE 8]><!--> <html class="no-js" lang="en" > <!--<![endif]-->
<head>
  <meta charset="utf-8">
  
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  
  <title>Job Types &mdash; Ash 0.1 documentation</title>
  

  
  
  
  

  
  <script type="text/javascript" src="_static/js/modernizr.min.js"></script>
  
    
      <script type="text/javascript" id="documentation_options" data-url_root="./" src="_static/documentation_options.js"></script>
        <script src="_static/jquery.js"></script>
        <script src="_static/underscore.js"></script>
        <script src="_static/doctools.js"></script>
        <script src="_static/language_data.js"></script>
        <script async="async" src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/latest.js?config=TeX-AMS-MML_HTMLorMML"></script>
    
    <script type="text/javascript" src="_static/js/theme.js"></script>

    

  
  <link rel="stylesheet" href="_static/css/theme.css" type="text/css" />
  <link rel="stylesheet" href="_static/pygments.css" type="text/css" />
  <link rel="stylesheet" href="_static/my_theme.css" type="text/css" />
    <link rel="index" title="Index" href="genindex.html" />
    <link rel="search" title="Search" href="search.html" />
    <link rel="next" title="QM Interfaces" href="QM-interfaces.html" />
    <link rel="prev" title="Coordinates and fragments" href="coordinate-input.html" /> 
</head>

<body class="wy-body-for-nav">

   
  <div class="wy-grid-for-nav">
    
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search"  style="background: white" >
          

          
            <a href="index.html" class="icon icon-home"> Ash
          

          
            
            <img src="_static/ash-simple-logo-letterbig.png" class="logo" alt="Logo"/>
          
          </a>

          
            
            
              <div class="version">
                0.1
              </div>
            
          

          
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>

          
        </div>

        <div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="main navigation">
          
            
            
              
            
            
              <p class="caption"><span class="caption-text">ASH</span></p>
<ul class="current">
<li class="toctree-l1"><a class="reference internal" href="About.html">About ASH</a></li>
<li class="toctree-l1"><a class="reference internal" href="setup.html">Setup</a></li>
<li class="toctree-l1"><a class="reference internal" href="basics.html">Basic usage</a></li>
<li class="toctree-l1"><a class="reference internal" href="coordinate-input.html">Coordinates and fragments</a></li>
<li class="toctree-l1 current"><a class="current reference internal" href="#">Job Types</a><ul>
<li class="toctree-l2"><a class="reference internal" href="#single-point-calculation">Single-point calculation</a></li>
<li class="toctree-l2"><a class="reference internal" href="#geometry-optimization">Geometry optimization</a></li>
<li class="toctree-l2"><a class="reference internal" href="#analytical-frequencies-hessian">Analytical frequencies (Hessian)</a></li>
<li class="toctree-l2"><a class="reference internal" href="#numerical-frequencies-hessian">Numerical frequencies (Hessian)</a></li>
<li class="toctree-l2"><a class="reference internal" href="#nudged-elastic-band-calculations">Nudged Elastic Band Calculations</a></li>
<li class="toctree-l2"><a class="reference internal" href="#surface-scans">Surface scans</a></li>
<li class="toctree-l2"><a class="reference internal" href="#saddle-point-optimization">Saddle-point optimization</a></li>
<li class="toctree-l2"><a class="reference internal" href="#molecular-dynamics">Molecular Dynamics</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="QM-interfaces.html">QM Interfaces</a></li>
<li class="toctree-l1"><a class="reference internal" href="MM-interfaces.html">MM Interfaces</a></li>
<li class="toctree-l1"><a class="reference internal" href="QM-MM.html">QM/MM Theory</a></li>
<li class="toctree-l1"><a class="reference internal" href="molcrys.html">MOLCRYS: Automatic QM/MM for Molecular Crystals</a></li>
<li class="toctree-l1"><a class="reference internal" href="pes.html">PES: PhotoElectron/PhotoEmission Spectrum</a></li>
<li class="toctree-l1"><a class="reference internal" href="workflows.html">Workflows in ASH</a></li>
<li class="toctree-l1"><a class="reference internal" href="benchmarking.html">Benchmarking in ASH</a></li>
<li class="toctree-l1"><a class="reference internal" href="thermochemistry.html">High-level Thermochemistry in ASH</a></li>
<li class="toctree-l1"><a class="reference internal" href="ash-classes.html">Ash object classes</a></li>
</ul>
<p class="caption"><span class="caption-text">Tools</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="coordinate-tools.html">Coordinates and fragment tools</a></li>
<li class="toctree-l1"><a class="reference internal" href="plotting.html">Plotting results</a></li>
</ul>

            
          
        </div>
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap">

      
      <nav class="wy-nav-top" aria-label="top navigation">
        
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="index.html">Ash</a>
        
      </nav>


      <div class="wy-nav-content">
        
        <div class="rst-content">
        
          















<div role="navigation" aria-label="breadcrumbs navigation">

  <ul class="wy-breadcrumbs">
    
      <li><a href="index.html">Docs</a> &raquo;</li>
        
      <li>Job Types</li>
    
    
      <li class="wy-breadcrumbs-aside">
        
            
            <a href="_sources/job-types.rst.txt" rel="nofollow"> View page source</a>
          
        
      </li>
    
  </ul>

  
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
            
  <div class="section" id="job-types">
<h1>Job Types<a class="headerlink" href="#job-types" title="Permalink to this headline">¶</a></h1>
<p>The job-types available in ASH:</p>
<ul class="simple">
<li><p>Single-point energy/property jobs in Ash (instead of using the QM code directly) are useful for the purpose of doing electrostatically embedded QM/MM, running multiple energy/property calculations in parallel, creating advanced workflows etc.</p></li>
<li><p>Geometry optimizations can be performed using a simple internal Optimizer or via more flexible external optimizers that can be easily installed.</p></li>
<li><p>Numerical frequencies can be performed for any Hamiltonian (QM, MM or QM/MM). Analytical frequencies available for some theories.</p></li>
<li><p>Nudged elastic band calculations are available via an interface to the Knarr-NEB code.</p></li>
<li><p>Molecular dynamics (not ready).</p></li>
</ul>
<p>The job-types can be used with any theory object available, e.g. one of the QMTheories in <a class="reference internal" href="QM-interfaces.html"><span class="doc">QM Interfaces</span></a> or using
a QM/MM Theory object from <a class="reference internal" href="QM-MM.html"><span class="doc">QM/MM Theory</span></a></p>
<div class="section" id="single-point-calculation">
<h2>Single-point calculation<a class="headerlink" href="#single-point-calculation" title="Permalink to this headline">¶</a></h2>
<p>A single-point calculation is the most basic job to perform.
After creating an Ash fragment, you create a Theory object, e.g. a QMTheory from: <a class="reference internal" href="QM-interfaces.html"><span class="doc">QM Interfaces</span></a> an
MMTheory (see <a class="reference internal" href="MM-interfaces.html"><span class="doc">MM Interfaces</span></a>) or a QM/MMTheory (see <a class="reference internal" href="QM-MM.html"><span class="doc">QM/MM Theory</span></a>).
The ORCATheory class is recommended as a QM code in general as this interface is more supported than others.
ORCA contains a large variety of DFT and WFT methods.
Below, ORCAobject is created from the ORCATheory class, passing various ORCA-specific variables to it
(location of ORCA dir and specifying how the inputfile should look).</p>
<p>For a single-point calculation only then simply passes the Theory object and the Fragment object to the <strong>Singlepoint</strong>
function.</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="kn">from</span> <span class="nn">ash</span> <span class="kn">import</span> <span class="o">*</span>
<span class="kn">import</span> <span class="nn">sys</span>
<span class="n">settings_ash</span><span class="o">.</span><span class="n">init</span><span class="p">()</span> <span class="c1">#initialize</span>

<span class="n">HF_frag</span><span class="o">=</span><span class="n">Fragment</span><span class="p">(</span><span class="n">xyzfile</span><span class="o">=</span><span class="s2">&quot;hf.xyz&quot;</span><span class="p">)</span>
<span class="c1">#ORCA</span>
<span class="n">orcadir</span><span class="o">=</span><span class="s1">&#39;/opt/orca_4.2.1&#39;</span>
<span class="n">orcasimpleinput</span><span class="o">=</span><span class="s2">&quot;! BP86 def2-SVP Grid5 Finalgrid6 tightscf&quot;</span>
<span class="n">orcablocks</span><span class="o">=</span><span class="s2">&quot;</span><span class="si">%s</span><span class="s2">cf maxiter 200 end&quot;</span>
<span class="n">ORCAobject</span> <span class="o">=</span> <span class="n">ORCATheory</span><span class="p">(</span><span class="n">orcadir</span><span class="o">=</span><span class="n">orcadir</span><span class="p">,</span> <span class="n">charge</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">mult</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span>
                    <span class="n">orcasimpleinput</span><span class="o">=</span><span class="n">orcasimpleinput</span><span class="p">,</span> <span class="n">orcablocks</span><span class="o">=</span><span class="n">orcablocks</span><span class="p">,</span> <span class="n">nprocs</span><span class="o">=</span><span class="mi">4</span><span class="p">)</span>

<span class="c1">#Simple Energy SP calc. Energy will be printed to output</span>
<span class="n">Singlepoint</span><span class="p">(</span><span class="n">theory</span><span class="o">=</span><span class="n">ORCAobject</span><span class="p">,</span> <span class="n">fragment</span><span class="o">=</span><span class="n">HF_frag</span><span class="p">)</span>
</pre></div>
</div>
<p>The <strong>Singlepoint</strong> function will run an ORCA calculation using the ORCAobject and the coordinates from the HF_frag fragment.
The energy will be printed to standard output by default</p>
<p>We can also run the calculation and store the energy as a new variable (to be used for anything):</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="c1">#Simple Energy+Gradient SP calc</span>
<span class="c1"># The function will return the energy that can be stored as a variable</span>
<span class="n">Energy</span> <span class="o">=</span> <span class="n">Singlepoint</span><span class="p">(</span><span class="n">theory</span><span class="o">=</span><span class="n">ORCAobject</span><span class="p">,</span> <span class="n">fragment</span><span class="o">=</span><span class="n">HF_frag</span><span class="p">)</span>
<span class="nb">print</span><span class="p">(</span><span class="s2">&quot;Energy is&quot;</span><span class="p">,</span> <span class="n">Energy</span><span class="p">)</span>
</pre></div>
</div>
<p>It is also possible to request a gradient calculation :</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="c1">#Simple Energy+Gradient SP calc</span>
<span class="n">Energy</span><span class="p">,</span> <span class="n">Gradient</span> <span class="o">=</span> <span class="n">Singlepoint</span><span class="p">(</span><span class="n">theory</span><span class="o">=</span><span class="n">ORCAobject</span><span class="p">,</span> <span class="n">fragment</span><span class="o">=</span><span class="n">HF_frag</span><span class="p">,</span> <span class="n">Grad</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
<span class="nb">print</span><span class="p">(</span><span class="s2">&quot;Energy is&quot;</span><span class="p">,</span> <span class="n">Energy</span><span class="p">)</span>
<span class="nb">print</span><span class="p">(</span><span class="s2">&quot;Gradient is:&quot;</span><span class="p">,</span> <span class="n">Gradient</span><span class="p">)</span>
</pre></div>
</div>
<p>By default, the files created by the Theory interface are not cleaned up. To have ORCA (in this example) clean up
temporary files (e.g. so they don’t interfere with a future job), one can use the cleanup function:</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="c1">#Clean up</span>
<span class="n">ORCAobject</span><span class="o">.</span><span class="n">cleanup</span><span class="p">()</span>
</pre></div>
</div>
<p>The energy and gradient from the last Energy/Energy+Gradient run is also stored inside the Theory object and can be accessed:</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="nb">print</span><span class="p">(</span><span class="n">ORCAobject</span><span class="o">.</span><span class="n">energy</span><span class="p">)</span>
<span class="nb">print</span><span class="p">(</span><span class="n">ORCAobject</span><span class="o">.</span><span class="n">grad</span><span class="p">)</span>
</pre></div>
</div>
</div>
<div class="section" id="geometry-optimization">
<h2>Geometry optimization<a class="headerlink" href="#geometry-optimization" title="Permalink to this headline">¶</a></h2>
<p>Geometry optimizations are easily performed in Ash due to availability of the flexible optimizer: geomeTRIC (<a class="reference external" href="https://github.com/leeping/geomeTRIC">https://github.com/leeping/geomeTRIC</a>)
geomeTRIC allows efficient optimization in multiple coordinate systems: TRIC, HDLC, DLC, Cartesian, redundant internals. Supports constraints as well as frozen atoms natively. Furthermore, the “ActiveRegion” feature inside Ash allows definition of an active region that allows efficient QM/MM optimizations of large systems (where most atoms are frozen). Only the active region coordinates are passed to geomeTRIC.
ASH features a full-featured interface to geomeTRIC that allows flexible constraint input, QM/MM optimizations, relaxed and unrelaxed 1D/2D surface scans and more.</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="kn">from</span> <span class="nn">ash</span> <span class="kn">import</span> <span class="o">*</span>
<span class="kn">import</span> <span class="nn">sys</span>
<span class="n">settings_ash</span><span class="o">.</span><span class="n">init</span><span class="p">()</span> <span class="c1">#initialize</span>

<span class="n">HF_frag</span><span class="o">=</span><span class="n">Fragment</span><span class="p">(</span><span class="n">xyzfile</span><span class="o">=</span><span class="s2">&quot;hf.xyz&quot;</span><span class="p">)</span>
<span class="c1">#ORCA</span>
<span class="n">orcadir</span><span class="o">=</span><span class="s1">&#39;/opt/orca_4.2.1&#39;</span>
<span class="n">orcasimpleinput</span><span class="o">=</span><span class="s2">&quot;! BP86 def2-SVP Grid5 Finalgrid6 tightscf&quot;</span>
<span class="n">orcablocks</span><span class="o">=</span><span class="s2">&quot;</span><span class="si">%s</span><span class="s2">cf maxiter 200 end&quot;</span>
<span class="n">ORCAcalc</span> <span class="o">=</span> <span class="n">ORCATheory</span><span class="p">(</span><span class="n">orcadir</span><span class="o">=</span><span class="n">orcadir</span><span class="p">,</span> <span class="n">charge</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">mult</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span>
                    <span class="n">orcasimpleinput</span><span class="o">=</span><span class="n">orcasimpleinput</span><span class="p">,</span> <span class="n">orcablocks</span><span class="o">=</span><span class="n">orcablocks</span><span class="p">)</span>
<span class="c1">#Note: if fragment is passed to optimizer it is not necessary to pass it to the QMtheory (here ORCAcalc) object</span>

<span class="c1">#Geometry optimization of the ORCA using geomeTRIC optimizer</span>
<span class="n">geomeTRICOptimizer</span><span class="p">(</span><span class="n">fragment</span><span class="o">=</span><span class="n">HF_frag</span><span class="p">,</span> <span class="n">theory</span><span class="o">=</span><span class="n">ORCAcalc</span><span class="p">,</span> <span class="n">coordsystem</span><span class="o">=</span><span class="s1">&#39;tric&#39;</span><span class="p">)</span>
</pre></div>
</div>
<p>Options to <strong>geometricOptimizer</strong>:</p>
<ul>
<li><p>coordsystem (Default: ‘tric’, other options: ‘hdlc’, ‘dlc’, ‘cartesian’, ‘prim’, ‘tric-p’)</p></li>
<li><p>frozenatoms (default: None, provide list of atoms to be frozen in space)</p></li>
<li><p>constraintsinputfile (default: None, provide name of constraints-inputfile according to geomeTRIC syntax.</p></li>
<li><p>constraints (default: None, provide dictionary of constraint definitions, with or without the value of the constraint. Example: constraints = { ‘bond’ : [[0,1]]}</p></li>
<li><p>constrainvalue (default: False, Boolean, whether constrain-value is provided in constraints dictionary or not)</p></li>
<li><p>maxiter (default: 50, maximum number of iterations)</p></li>
<li><p>ActiveRegion (default:False, whether to use an active region or not. Requires accompanying actatoms list.</p></li>
<li><p>actatoms (default: None, list of atoms that are active during optimization, all others are frozen)</p></li>
<li><p>convergence_setting (default: ‘ORCA’. What type of convergence criteria to use. Valid options are: ‘ORCA’, ‘Chemshell’, ‘ORCA_TIGHT’, ‘GAU’, ‘GAU_TIGHT’, ‘GAU_VERYTIGHT’, ‘SuperLoose’.</p>
<blockquote>
<div><ul class="simple">
<li><p>ORCA:    conv_criteria = {‘convergence_energy’ : 5e-6, ‘convergence_grms’ : 1e-4, ‘convergence_gmax’ : 3.0e-4, ‘convergence_drms’ : 2.0e-3, ‘convergence_dmax’ : 4.0e-3 }</p></li>
<li><p>Chemshell:    conv_criteria = {‘convergence_energy’ : 1e-6, ‘convergence_grms’ : 3e-4, ‘convergence_gmax’ : 4.5e-4, ‘convergence_drms’ : 1.2e-3, ‘convergence_dmax’ : 1.8e-3 }</p></li>
<li><p>ORCA_TIGHT:    conv_criteria = {‘convergence_energy’ : 1e-6, ‘convergence_grms’ : 3e-5, ‘convergence_gmax’ : 1.0e-4, ‘convergence_drms’ : 6.0e-4, ‘convergence_dmax’ : 1.0e-3 }</p></li>
<li><p>GAU:    conv_criteria = {‘convergence_energy’ : 1e-6, ‘convergence_grms’ : 3e-4, ‘convergence_gmax’ : 4.5e-4, ‘convergence_drms’ : 1.2e-3, ‘convergence_dmax’ : 1.8e-3 }</p></li>
<li><p>GAU_TIGHT:    conv_criteria = {‘convergence_energy’ : 1e-6, ‘convergence_grms’ : 1e-5, ‘convergence_gmax’ : 1.5e-5, ‘convergence_drms’ : 4.0e-5, ‘convergence_dmax’ : 6e-5 }</p></li>
<li><p>GAU_VERYTIGHT:    conv_criteria = {‘convergence_energy’ : 1e-6, ‘convergence_grms’ : 1e-6, ‘convergence_gmax’ : 2e-6, ‘convergence_drms’ : 4.0e-6, ‘convergence_dmax’ : 6e-6 }</p></li>
<li><p>SuperLoose:            conv_criteria = { ‘convergence_energy’ : 1e-1, ‘convergence_grms’ : 1e-1, ‘convergence_gmax’ : 1e-1, ‘convergence_drms’ : 1e-1, ‘convergence_dmax’ : 1e-1 }</p></li>
</ul>
</div></blockquote>
</li>
<li><p>conv_criteria (Default: see ORCA setting above. Optionally provide your own dictionary of settings using syntax above.</p></li>
</ul>
<p>Other optimizers:</p>
<ul class="simple">
<li><p>An internal optimizer is available (called “SimpleOpt”) that can optimize the system in Cartesian coordinates only using the LBFGS algorithm. While frozen atoms are supported, no other constraints are supported.</p></li>
<li><p>An interface to the PyBerny optimization program (<a class="reference external" href="https://github.com/jhrmnn/pyberny">https://github.com/jhrmnn/pyberny</a>) is available that allows efficient optimizations in redundant internal coordinates. No frozen atoms or constraints are available currently. PyBerny requires installation via pip.</p></li>
</ul>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="c1">#PyBerny example:</span>
<span class="n">BernyOpt</span><span class="p">(</span><span class="n">ORCAcalc</span><span class="p">,</span><span class="n">HF_frag</span><span class="p">)</span>

<span class="c1"># Internal Cartesian-LBFGS Optimizer:</span>
<span class="n">SimpleOpt</span><span class="p">(</span><span class="n">fragment</span><span class="o">=</span><span class="n">HF_frag</span><span class="p">,</span> <span class="n">theory</span><span class="o">=</span><span class="n">ORCAcalc</span><span class="p">,</span> <span class="n">optimizer</span><span class="o">=</span><span class="s1">&#39;KNARR-LBFGS&#39;</span><span class="p">,</span> <span class="n">frozen_atoms</span><span class="o">=</span><span class="p">[])</span>
</pre></div>
</div>
</div>
<div class="section" id="analytical-frequencies-hessian">
<h2>Analytical frequencies (Hessian)<a class="headerlink" href="#analytical-frequencies-hessian" title="Permalink to this headline">¶</a></h2>
<p>Analytical frequencies can be requested in some cases if supported by the theory-level interface as well as the Hamiltonian inside program.
Currently analytical frequencies are supported in: ORCATheory</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="k">def</span> <span class="nf">AnFreq</span><span class="p">(</span><span class="n">fragment</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">theory</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">numcores</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">temp</span><span class="o">=</span><span class="mf">298.15</span><span class="p">,</span> <span class="n">pressure</span><span class="o">=</span><span class="mf">1.0</span><span class="p">)</span>
</pre></div>
</div>
<p>Example:</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="n">HF_frag</span><span class="o">=</span><span class="n">Fragment</span><span class="p">(</span><span class="n">xyzfile</span><span class="o">=</span><span class="s2">&quot;hf.xyz&quot;</span><span class="p">)</span>
<span class="n">ORCAcalc</span> <span class="o">=</span> <span class="n">ORCATheory</span><span class="p">(</span><span class="n">orcadir</span><span class="o">=</span><span class="s1">&#39;/opt/orca_4.2.1&#39;</span><span class="p">,</span> <span class="n">charge</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">mult</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span>
                    <span class="n">orcasimpleinput</span><span class="o">=</span><span class="s1">&#39;BP def2-SVP def2/J&#39;</span><span class="p">,</span> <span class="n">orcablocks</span><span class="o">=</span><span class="s2">&quot;, nprocs=1)</span>
<span class="n">thermochem_dict</span> <span class="o">=</span> <span class="n">AnFreq</span><span class="p">(</span><span class="n">theory</span><span class="o">=</span><span class="n">ORCAcalc</span><span class="p">,</span> <span class="n">fragment</span><span class="o">=</span><span class="n">HF_frag</span><span class="p">)</span>

<span class="nb">print</span><span class="p">(</span><span class="s2">&quot;Thermochem properties dict:&quot;</span><span class="p">,</span> <span class="n">thermochem_dict</span><span class="p">)</span>
<span class="nb">print</span><span class="p">(</span><span class="s2">&quot;Vibrational frequencies (cm**-1) : &quot;</span><span class="p">,</span> <span class="n">thermochem_dict</span><span class="p">[</span><span class="s1">&#39;freqs&#39;</span><span class="p">])</span>
<span class="nb">print</span><span class="p">(</span><span class="s2">&quot;ZPVE (Eh) : &quot;</span><span class="p">,</span> <span class="n">thermochem_dict</span><span class="p">[</span><span class="s1">&#39;ZPVE&#39;</span><span class="p">])</span>
<span class="nb">print</span><span class="p">(</span><span class="s2">&quot;Gibbs energy corrections (Eh) : &quot;</span><span class="p">,</span> <span class="n">thermochem_dict</span><span class="p">[</span><span class="s1">&#39;Gcorr&#39;</span><span class="p">])</span>
</pre></div>
</div>
<p>A dictionary containing various properties is returned (dictionary keys) from an AnFreq job:
(freqs, ZPVE, E_trans, E_rot, E_vib, E_tot, TS_trans, TS_rot, TS_vib, TS_el, vibenergycorr, Hcorr, Gcorr, TS_tot)</p>
</div>
<div class="section" id="numerical-frequencies-hessian">
<h2>Numerical frequencies (Hessian)<a class="headerlink" href="#numerical-frequencies-hessian" title="Permalink to this headline">¶</a></h2>
<p>Numerical frequencies can be performed with Ash using any QM, MM or QM/MM theory object.
Any method for which there is an analytical gradient (forces) available can be used (numerical 2nd derivative on top of numerical 1st derivative is not recommended).</p>
<p>Use the <strong>NumFreq</strong> function to request a numerical frequency job. The function requires a fragment object and a theory level at minimum.
The fragment object should typically contain a fragment with optimized coordinates at same level of theory (i.e. an already optimized minimum or saddlepoint).</p>
<p><em>Type of Hessian</em>
Additionally you can select to do a 1-point Hessian or a 2-point Hessian by the <em>npoint</em> keyword (value of 1 or 2).
A 1-point Hessian makes a single displacement (+ direction) for each atom and each x,y and z-coordinate from the input geometry. This option is reasonably accurate and is the default.
A more accurate 2-point Hessian makes displacement in both + and - directions (for each x-, y- and z-coordinate of each atom), is twice as expensive (double the displacements)
but is more accurate.
The displacement step can be chosen if wanted. The default setting is: 0.0005 Å.</p>
<p><em>Serial or parallel</em>
Two runmodes are available: ‘serial’ and ‘parallel’. The ‘serial’ mode will run each displacement sequentially.
The Energy+Gradient step can still be run in parallel if e.g. the QM or QM/MM object has this information;
e.g. if an ORCA object has been defined with nprocs=8 then ORCA will run each Energy+Gradient evaluation with 8 cores using the OpenMPI parallelization of ORCA.
For numerical frequencies, it is usually much more efficient, however, to run the displacement jobs simutaneously in parallel fashion.
This is accomplished using runmode=’parallel’ and the parallelization will be linear scaling (almost always recommended).
As there are almost always many more displacements available than CPUs, the parallelization of the QM or QM/MM object is turned off and instead as many displacements
are run simultaneously as there are number of cores. For example, for a 30-atom system, there are 90 XYZ coordinates. For a 2-point Hessian, this means
that 180 displacements to be calculated. If 20 cores are available, then 20 displacements can be run simultaneously, fully utilizing all 20 cores.
This will require 9 runs in total (20*9=180).</p>
<p><em>Full or partial Hessian</em></p>
<p>A partial Hessian (NEEDS TO BE TESTED) can be easily performed instead of the full Hessian. This is an excellent approximation for vibrational modes with rather local character
and the quality of the approximation can be controlled. For a QM/MM model of a protein active site with an active region of a 1000 atoms, the full Hessian
of all 1000 atoms would typically not be doable; instead a partial Hessian job of the important atoms (e.g. the QM region) makes more sense.
A partial Hessian job is performed if a list of Hessian atoms (e.g. hessatoms=[0,1,2] ) is passed to the NumFreq function. In this case, the displacements
will only be calculated for the list of “hessatoms” and the result is a partial Hessian for the system.</p>
<p><em>Final output</em>
Once the displacements are complete, the gradients for all displacements are combined to give the full (or partial) Hessian.
The Hessian is then mass-weighted and diagonalized. (Limitation: translational and rotational modes are currently not projected out).
This gives the frequencies as eigenvalues and the normal mode eigenvectors.
A normal mode composition factor analysis is automatically performed (NOT READY) as well as zero-point energy thermochemistry.</p>
<p>Example script below demonstrates a combined geometry optimization (using geomeTRIC).
The QM code used here is ORCA but any QM, MM or QM/MM object can be used.</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="kn">from</span> <span class="nn">ash</span> <span class="kn">import</span> <span class="o">*</span>
<span class="kn">import</span> <span class="nn">sys</span>
<span class="n">settings_ash</span><span class="o">.</span><span class="n">init</span><span class="p">()</span> <span class="c1">#initialize</span>

<span class="c1">#the total number of CPU cores available to Ash (should match the job-script)</span>
<span class="n">Ashnumcores</span><span class="o">=</span><span class="mi">8</span>

<span class="n">orcadir</span><span class="o">=</span><span class="s1">&#39;/opt/orca_4.2.1&#39;</span>
<span class="n">orcasimpleinput</span><span class="o">=</span><span class="s2">&quot;! HF-3c &quot;</span>
<span class="n">orcablocks</span><span class="o">=</span><span class="s2">&quot;</span><span class="si">%s</span><span class="s2">cf maxiter 200 end&quot;</span>

<span class="n">reactstring</span><span class="o">=</span><span class="s2">&quot;&quot;&quot;</span>
<span class="s2">   C  -2.66064921   -0.44148342    0.02830018</span>
<span class="s2">   H  -2.26377685   -1.23173358    0.68710920</span>
<span class="s2">   H  -2.29485851   -0.62084858   -0.99570465</span>
<span class="s2">   H  -2.27350346    0.53131334    0.37379014</span>
<span class="s2">   F  -4.03235214   -0.44462811    0.05296388</span>
<span class="s2">&quot;&quot;&quot;</span>
<span class="n">Reactant</span><span class="o">=</span><span class="n">Fragment</span><span class="p">(</span><span class="n">coordsstring</span><span class="o">=</span><span class="n">reactstring</span><span class="p">)</span>

<span class="c1">#Calculator object without frag. nprocs=8 is used here for parallelizing ORCA during optimization.</span>
<span class="n">ORCAcalc</span> <span class="o">=</span> <span class="n">ORCATheory</span><span class="p">(</span><span class="n">orcadir</span><span class="o">=</span><span class="n">orcadir</span><span class="p">,</span> <span class="n">charge</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">mult</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">orcasimpleinput</span><span class="o">=</span><span class="n">orcasimpleinput</span><span class="p">,</span> <span class="n">orcablocks</span><span class="o">=</span><span class="n">orcablocks</span><span class="p">,</span> <span class="n">nprocs</span><span class="o">=</span><span class="n">Ashnumcores</span><span class="p">)</span>

<span class="c1">#Geometry optimization of Reactant object and ORCAcalc theory object.</span>
<span class="c1">#Each Energy+Grad step is parallelized by ORCA.</span>
<span class="n">geomeTRICOptimizer</span><span class="p">(</span><span class="n">theory</span><span class="o">=</span><span class="n">ORCAcalc</span><span class="p">,</span><span class="n">fragment</span><span class="o">=</span><span class="n">Reactant</span><span class="p">)</span>


<span class="c1">#Numfreq job. A 1-point or 2-point Hessian can be requested.</span>
<span class="c1"># Either serial or parallell runmode can be used.</span>
<span class="c1"># For parallel: Ash will use the number of cores given to run same number of displacments simultaneouslyu.</span>
<span class="c1">#ORCA parallelization is turned off automatically.</span>

<span class="c1">#Serial mode:</span>
<span class="n">freqresult</span> <span class="o">=</span> <span class="n">NumFreq</span><span class="p">(</span><span class="n">fragment</span><span class="o">=</span><span class="n">Reactant</span><span class="p">,</span> <span class="n">theory</span><span class="o">=</span><span class="n">ORCAcalc</span><span class="p">,</span> <span class="n">npoint</span><span class="o">=</span><span class="mi">2</span><span class="p">,</span> <span class="n">runmode</span><span class="o">=</span><span class="s1">&#39;serial&#39;</span><span class="p">)</span>
<span class="c1">#Parallel mode:</span>
<span class="n">freqresult</span> <span class="o">=</span> <span class="n">NumFreq</span><span class="p">(</span><span class="n">fragment</span><span class="o">=</span><span class="n">Reactant</span><span class="p">,</span> <span class="n">theory</span><span class="o">=</span><span class="n">ORCAcalc</span><span class="p">,</span> <span class="n">npoint</span><span class="o">=</span><span class="mi">2</span><span class="p">,</span> <span class="n">runmode</span><span class="o">=</span><span class="s1">&#39;parallel&#39;</span><span class="p">,</span> <span class="n">numcores</span><span class="o">=</span><span class="n">Ashnumcores</span><span class="p">)</span>

<span class="nb">print</span><span class="p">(</span><span class="s2">&quot;freqresult:&quot;</span><span class="p">,</span> <span class="n">freqresult</span><span class="p">)</span>
<span class="c1">#The resulting object from a NumFreq calculation is a dictionary (here called freqresult)</span>
<span class="c1"># It contains the calculated frequencies and results from the Thermochemical analysis.</span>
<span class="c1">#Individual items from the dictionary can be accessed by specifying the dictionary key:</span>
<span class="c1"># Available keys: frequencies, ZPVE, vibenergy, transenergy, rotenergy, vibenergy, vibenergycorr</span>
<span class="c1"># TO BE FINISHED...</span>
<span class="nb">print</span><span class="p">(</span><span class="s2">&quot;Frequencies : &quot;</span><span class="p">,</span> <span class="n">freqresult</span><span class="p">[</span><span class="s1">&#39;frequencies])</span>
<span class="nb">print</span><span class="p">(</span><span class="s2">&quot;ZPVE : &quot;</span><span class="p">,</span> <span class="n">freqresult</span><span class="p">[</span><span class="s1">&#39;ZPVE])</span>
</pre></div>
</div>
</div>
<div class="section" id="nudged-elastic-band-calculations">
<h2>Nudged Elastic Band Calculations<a class="headerlink" href="#nudged-elastic-band-calculations" title="Permalink to this headline">¶</a></h2>
<p>Through an interface to an external code, nudged elastic band (NEB) calculations are possible.
Both regular NEB and CI-NEB calculations are possible.</p>
<p>Any QM or QM/MM Hamiltonian can be used.</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="kn">from</span> <span class="nn">ash</span> <span class="kn">import</span> <span class="o">*</span>
<span class="kn">import</span> <span class="nn">sys</span>
<span class="n">settings_ash</span><span class="o">.</span><span class="n">init</span><span class="p">()</span> <span class="c1">#initialize</span>
<span class="kn">import</span> <span class="nn">interface_knarr</span>

<span class="n">Reactant</span><span class="o">=</span><span class="n">Fragment</span><span class="p">(</span><span class="n">xyzfile</span><span class="o">=</span><span class="s2">&quot;react.xyz&quot;</span><span class="p">)</span>
<span class="n">Product</span><span class="o">=</span><span class="n">Fragment</span><span class="p">(</span><span class="n">xyzfile</span><span class="o">=</span><span class="s2">&quot;prod.xyz&quot;</span><span class="p">)</span>

<span class="c1">#Calculator object without frag</span>
<span class="n">xtbcalc</span> <span class="o">=</span> <span class="n">xTBTheory</span><span class="p">(</span><span class="n">charge</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">mult</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">xtbmethod</span><span class="o">=</span><span class="s1">&#39;GFN2&#39;</span><span class="p">,</span> <span class="n">runmode</span><span class="o">=</span><span class="s1">&#39;library&#39;</span><span class="p">)</span>

<span class="n">interface_knarr</span><span class="o">.</span><span class="n">NEB</span><span class="p">(</span><span class="n">reactant</span><span class="o">=</span><span class="n">Reactant</span><span class="p">,</span> <span class="n">product</span><span class="o">=</span><span class="n">Product</span><span class="p">,</span> <span class="n">theory</span><span class="o">=</span><span class="n">xtbcalc</span><span class="p">,</span> <span class="n">images</span><span class="o">=</span><span class="mi">10</span><span class="p">,</span> <span class="n">CI</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
</pre></div>
</div>
</div>
<div class="section" id="surface-scans">
<h2>Surface scans<a class="headerlink" href="#surface-scans" title="Permalink to this headline">¶</a></h2>
<p>Potential Energy Surfaces can be conveniently scanned in ASH using the <strong>calc_surface function</strong> that uses the <strong>geometric</strong> optimization library.
Both unrelaxed and relaxed scans be calculated, using either 1 and 2 reaction coordinates.</p>
<p>The calc_surface function takes a fragment object and theory object as input. The type of scan is specified (‘Unrelaxed’ or ‘Relaxed’) and
then either 1 or 2 reaction coordinates are specified via keyword arguments: RC1_type, RC1_range and RC1_indices (and RC2 versions if using two reaction coordinates).</p>
<ul class="simple">
<li><p>The RC1_type/RC2_type keyword can be: ‘bond’, ‘angle’ or ‘dihedral’.</p></li>
<li><p>The RC1_indices/RC2_indices keyword defines the atom indices for the bond/angle/dihedral. Note: ASH counts from zero.</p></li>
<li><p>The RC1_range/RC2_range keyword species the start coordinate, end coordinate and the stepsize (Å units for bonds, ° for angles/dihedrals).</p></li>
</ul>
<p>The resultfile keyword should be used to specify the name of the file that contains the results of the scan ( format: coord1 coord2 energy).
This file can be used to restart an incomplete/failed scan. If ASH finds this file in the same dir as the script, it will read the data and skip unneeded calculations.
Default name : ‘surface_results.txt’</p>
<p><strong>calc_surface</strong> returns a dictionary of total energies for each surface point. The key is a tuple of coordinate value and the value is the energy, i.e.
(RC1value,RC2value) : energy</p>
<p><strong>1D scan:</strong></p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="n">surfacedictionary</span> <span class="o">=</span> <span class="n">calc_surface</span><span class="p">(</span><span class="n">fragment</span><span class="o">=</span><span class="n">frag</span><span class="p">,</span> <span class="n">theory</span><span class="o">=</span><span class="n">ORCAcalc</span><span class="p">,</span> <span class="nb">type</span><span class="o">=</span><span class="s1">&#39;Unrelaxed&#39;</span><span class="p">,</span> <span class="n">resultfile</span><span class="o">=</span><span class="s1">&#39;surface_results.txt&#39;</span><span class="p">,</span> <span class="n">runmode</span><span class="o">=</span><span class="s1">&#39;serial&#39;</span><span class="p">,</span>
    <span class="n">RC1_range</span><span class="o">=</span><span class="p">[</span><span class="mi">180</span><span class="p">,</span><span class="mi">110</span><span class="p">,</span><span class="o">-</span><span class="mi">10</span><span class="p">],</span> <span class="n">RC1_type</span><span class="o">=</span><span class="s1">&#39;angle&#39;</span><span class="p">,</span> <span class="n">RC1_indices</span><span class="o">=</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">2</span><span class="p">])</span>
</pre></div>
</div>
<p><strong>2D scan:</strong></p>
<p>If both RC1 and RC2 keywords are provided then a 2D scan will be calculated.</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="n">surfacedictionary</span> <span class="o">=</span> <span class="n">calc_surface</span><span class="p">(</span><span class="n">fragment</span><span class="o">=</span><span class="n">frag</span><span class="p">,</span> <span class="n">theory</span><span class="o">=</span><span class="n">ORCAcalc</span><span class="p">,</span> <span class="nb">type</span><span class="o">=</span><span class="s1">&#39;Unrelaxed&#39;</span><span class="p">,</span> <span class="n">resultfile</span><span class="o">=</span><span class="s1">&#39;surface_results.txt&#39;</span><span class="p">,</span> <span class="n">runmode</span><span class="o">=</span><span class="s1">&#39;serial&#39;</span><span class="p">,</span>
    <span class="n">RC1_type</span><span class="o">=</span><span class="s1">&#39;bond&#39;</span><span class="p">,</span> <span class="n">RC1_range</span><span class="o">=</span><span class="p">[</span><span class="mf">2.0</span><span class="p">,</span><span class="mf">2.2</span><span class="p">,</span><span class="mf">0.01</span><span class="p">],</span> <span class="n">RC1_indices</span><span class="o">=</span><span class="p">[[</span><span class="mi">0</span><span class="p">,</span><span class="mi">1</span><span class="p">],[</span><span class="mi">0</span><span class="p">,</span><span class="mi">2</span><span class="p">]],</span> <span class="n">RC2_range</span><span class="o">=</span><span class="p">[</span><span class="mi">180</span><span class="p">,</span><span class="mi">110</span><span class="p">,</span><span class="o">-</span><span class="mi">10</span><span class="p">],</span> <span class="n">RC2_type</span><span class="o">=</span><span class="s1">&#39;angle&#39;</span><span class="p">,</span> <span class="n">RC2_indices</span><span class="o">=</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">2</span><span class="p">])</span>
</pre></div>
</div>
<p>NOTE: It is possible to have each chosen reaction coordinate apply to multiple sets of atom indices by specifying a list of lists.
In the 2D scan example above, the RC1_indices keyword (a ‘bond’ reaction coordinate) will apply to both atoms [0,1] as well as [0,2].
This makes sense when preserving symmetry of a system e.g. the O-H bonds in H2O.</p>
<p>NOTE: Currently the runmode is serial which means that one surface point is run after the other and only the theory level can be parallelized.
A future parallel runmode will become available where X surfacepoints can be run simultaneously using X available cores.</p>
<p>Other options to calc_surface:</p>
<ul class="simple">
<li><p>coordsystem  (for geomeTRICOptimizer, default: ‘dlc’. Other options: ‘hdlc’ and ‘tric’)</p></li>
<li><p>maxiter (for geomeTRICOptimizer,default : 50)</p></li>
<li><p>extraconstraints (for geomeTRICOptimizer, default : None. dictionary of additional constraints. Same syntax as constraints in <strong>geomeTRICOptimizer</strong>)</p></li>
<li><p>convergence_setting (for geomeTRICOptimizer, same syntax as in <strong>geomeTRICOptimizer</strong>)</p></li>
</ul>
<p><strong>Working with a previous scan from collection of XYZ files</strong></p>
<p>If a surface scan has already been performed, it’s possible to use the created XYZ-files and calculate energies for each surfacepoint with
e.g. a high-level of theory (CCSD(T) for instance).</p>
<p>We can use the <strong>calc_surface_fromXYZ</strong> function to read in previous XYZ-files (named like this: RC1_2.0-RC2_180.0.xyz for a 2D scan and like this: RC1_2.0.xyz for a 1D scan).
These files should have been created from <strong>calc_surface</strong> already (present in surface_xyzfiles results directory).
By providing a theory level object we can then easily perform single-point calculations for each surface point.
The results is a dictionary like before.</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="c1">#Directory of XYZ files. Can be full path or relative path.</span>
<span class="n">surfacedir</span> <span class="o">=</span> <span class="s1">&#39;/users/home/ragnarbj/Fe2S2Cl4/PES/Relaxed-Scan-test1/SP-DLPNOCC/surface_xyzfiles&#39;</span>

<span class="c1">#Calculate surface from collection of XYZ files. Will read old surface-results.txt file if requested (resultfile=&quot;surface-results.txt&quot;)</span>
<span class="n">surfacedictionary</span> <span class="o">=</span> <span class="n">calc_surface_fromXYZ</span><span class="p">(</span><span class="n">xyzdir</span><span class="o">=</span><span class="n">surfacedir</span><span class="p">,</span> <span class="n">theory</span><span class="o">=</span><span class="n">ORCAcalc</span><span class="p">,</span> <span class="n">dimension</span><span class="o">=</span><span class="mi">2</span><span class="p">,</span> <span class="n">resultfile</span><span class="o">=</span><span class="s1">&#39;surface_results.txt&#39;</span> <span class="p">)</span>
</pre></div>
</div>
<p><strong>Plotting</strong></p>
<p>The final result of the scan is stored in a dictionary (named ‘surfacedictionary’ in the examples above) and can be easily
plotted by giving the dictionary as input to plotting functions (based on Matplotlib).
See <a class="reference internal" href="plotting.html"><span class="doc">Plotting results</span></a>) page.</p>
<p>The dictionary has the format: (coord1,coord2) : energy  for a 2D scan  and (coord1) : energy for a 1D scan
where (coord1,coord2)/(coord1) is a tuple of floats and energy is the total energy as a float.</p>
<p>A dictionary using data from a previous job (stored e.g. in surface_results.txt) can be created via the <strong>read_surfacedict_from_file</strong> function:</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="n">surfacedictionary</span> <span class="o">=</span> <span class="n">read_surfacedict_from_file</span><span class="p">(</span><span class="s2">&quot;surface_results.txt&quot;</span><span class="p">,</span> <span class="n">dimension</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
</pre></div>
</div>
</div>
<div class="section" id="saddle-point-optimization">
<h2>Saddle-point optimization<a class="headerlink" href="#saddle-point-optimization" title="Permalink to this headline">¶</a></h2>
<p>Not yet ready</p>
</div>
<div class="section" id="molecular-dynamics">
<h2>Molecular Dynamics<a class="headerlink" href="#molecular-dynamics" title="Permalink to this headline">¶</a></h2>
<p>Not yet ready</p>
</div>
</div>


           </div>
           
          </div>
          <footer>
  
    <div class="rst-footer-buttons" role="navigation" aria-label="footer navigation">
      
        <a href="QM-interfaces.html" class="btn btn-neutral float-right" title="QM Interfaces" accesskey="n" rel="next">Next <span class="fa fa-arrow-circle-right"></span></a>
      
      
        <a href="coordinate-input.html" class="btn btn-neutral float-left" title="Coordinates and fragments" accesskey="p" rel="prev"><span class="fa fa-arrow-circle-left"></span> Previous</a>
      
    </div>
  

  <hr/>

  <div role="contentinfo">
    <p>
        &copy; Copyright 2020, Ragnar Bjornsson

    </p>
  </div>
  Built with <a href="http://sphinx-doc.org/">Sphinx</a> using a <a href="https://github.com/rtfd/sphinx_rtd_theme">theme</a> provided by <a href="https://readthedocs.org">Read the Docs</a>. 

</footer>

        </div>
      </div>

    </section>

  </div>
  


  <script type="text/javascript">
      jQuery(function () {
          SphinxRtdTheme.Navigation.enable(true);
      });
  </script>

  
  
    
    <!-- Theme Analytics -->
    <script>
    (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
      (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
      m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
    })(window,document,'script','https://www.google-analytics.com/analytics.js','ga');

    ga('create', 'UA-XXXXXXX-1', 'auto');
    ga('send', 'pageview');
    </script>

    
   

</body>
</html>