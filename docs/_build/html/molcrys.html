

<!DOCTYPE html>
<!--[if IE 8]><html class="no-js lt-ie9" lang="en" > <![endif]-->
<!--[if gt IE 8]><!--> <html class="no-js" lang="en" > <!--<![endif]-->
<head>
  <meta charset="utf-8">
  
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  
  <title>MOLCRYS: Automatic QM/MM for Molecular Crystals &mdash; Ash 0.1 documentation</title>
  

  
  
  
  

  
  <script type="text/javascript" src="_static/js/modernizr.min.js"></script>
  
    
      <script type="text/javascript" id="documentation_options" data-url_root="./" src="_static/documentation_options.js"></script>
        <script src="_static/jquery.js"></script>
        <script src="_static/underscore.js"></script>
        <script src="_static/doctools.js"></script>
        <script src="_static/language_data.js"></script>
        <script async="async" src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/latest.js?config=TeX-AMS-MML_HTMLorMML"></script>
    
    <script type="text/javascript" src="_static/js/theme.js"></script>

    

  
  <link rel="stylesheet" href="_static/css/theme.css" type="text/css" />
  <link rel="stylesheet" href="_static/pygments.css" type="text/css" />
  <link rel="stylesheet" href="_static/my_theme.css" type="text/css" />
    <link rel="index" title="Index" href="genindex.html" />
    <link rel="search" title="Search" href="search.html" />
    <link rel="next" title="PES: PhotoElectron/PhotoEmission Spectrum" href="pes.html" />
    <link rel="prev" title="QM/MM Theory" href="QM-MM.html" /> 
</head>

<body class="wy-body-for-nav">

   
  <div class="wy-grid-for-nav">
    
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search"  style="background: white" >
          

          
            <a href="index.html" class="icon icon-home"> Ash
          

          
            
            <img src="_static/ash-simple-logo-letterbig.png" class="logo" alt="Logo"/>
          
          </a>

          
            
            
              <div class="version">
                0.1
              </div>
            
          

          
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>

          
        </div>

        <div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="main navigation">
          
            
            
              
            
            
              <p class="caption"><span class="caption-text">Axx</span></p>
<ul class="current">
<li class="toctree-l1"><a class="reference internal" href="About.html">About ASH</a></li>
<li class="toctree-l1"><a class="reference internal" href="setup.html">Setup</a></li>
<li class="toctree-l1"><a class="reference internal" href="basics.html">Basic usage</a></li>
<li class="toctree-l1"><a class="reference internal" href="coordinate-input.html">Coordinates and fragments</a></li>
<li class="toctree-l1"><a class="reference internal" href="job-types.html">Job Types</a></li>
<li class="toctree-l1"><a class="reference internal" href="QM-interfaces.html">QM Interfaces</a></li>
<li class="toctree-l1"><a class="reference internal" href="MM-interfaces.html">MM Interfaces</a></li>
<li class="toctree-l1"><a class="reference internal" href="QM-MM.html">QM/MM Theory</a></li>
<li class="toctree-l1 current"><a class="current reference internal" href="#">MOLCRYS: Automatic QM/MM for Molecular Crystals</a><ul>
<li class="toctree-l2"><a class="reference internal" href="#molcrys-function-creating-a-cluster">MOLCRYS function: Creating a cluster</a></li>
<li class="toctree-l2"><a class="reference internal" href="#molcrys-example-spherical-qm-mm-cluster-setup-from-cif-file">MOLCRYS Example: Spherical QM/MM Cluster setup from CIF-file</a></li>
<li class="toctree-l2"><a class="reference internal" href="#molcrys-qm-mm-geometry-optimization">MOLCRYS: QM/MM Geometry optimization</a></li>
<li class="toctree-l2"><a class="reference internal" href="#molcrys-expanded-qm-region-calculation">MOLCRYS: Expanded QM region calculation</a></li>
<li class="toctree-l2"><a class="reference internal" href="#molcrys-property-calculation">MOLCRYS: Property calculation</a></li>
<li class="toctree-l2"><a class="reference internal" href="#molcrys-reaction-path-and-saddle-point-finding-via-neb-method">MOLCRYS: Reaction path and saddle-point finding via NEB method</a></li>
<li class="toctree-l2"><a class="reference internal" href="#molcrys-numerical-qm-mm-frequencies">MOLCRYS: Numerical QM/MM frequencies</a></li>
<li class="toctree-l2"><a class="reference internal" href="#molcrys-fragment-identification-connectivity-issues">MOLCRYS: Fragment identification/Connectivity issues</a></li>
<li class="toctree-l2"><a class="reference internal" href="#molcrys-molecular-dynamics">MOLCRYS: Molecular Dynamics</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="pes.html">PES: PhotoElectron/PhotoEmission Spectrum</a></li>
<li class="toctree-l1"><a class="reference internal" href="workflows.html">Workflows in ASH</a></li>
<li class="toctree-l1"><a class="reference internal" href="benchmarking.html">Benchmarking in ASH</a></li>
<li class="toctree-l1"><a class="reference internal" href="thermochemistry.html">High-level Thermochemistry in ASH</a></li>
<li class="toctree-l1"><a class="reference internal" href="ash-classes.html">Ash object classes</a></li>
</ul>
<p class="caption"><span class="caption-text">Tools</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="coordinate-tools.html">Coordinates and fragment tools</a></li>
<li class="toctree-l1"><a class="reference internal" href="plotting.html">Plotting results</a></li>
</ul>

            
          
        </div>
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap">

      
      <nav class="wy-nav-top" aria-label="top navigation">
        
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="index.html">Ash</a>
        
      </nav>


      <div class="wy-nav-content">
        
        <div class="rst-content">
        
          















<div role="navigation" aria-label="breadcrumbs navigation">

  <ul class="wy-breadcrumbs">
    
      <li><a href="index.html">Docs</a> &raquo;</li>
        
      <li>MOLCRYS: Automatic QM/MM for Molecular Crystals</li>
    
    
      <li class="wy-breadcrumbs-aside">
        
            
            <a href="_sources/molcrys.rst.txt" rel="nofollow"> View page source</a>
          
        
      </li>
    
  </ul>

  
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
            
  <div class="section" id="molcrys-automatic-qm-mm-for-molecular-crystals">
<h1>MOLCRYS: Automatic QM/MM for Molecular Crystals<a class="headerlink" href="#molcrys-automatic-qm-mm-for-molecular-crystals" title="Permalink to this headline">¶</a></h1>
<p>The molecular crystal QM/MM method in <strong>ASH</strong> is based on the work described
in articles by Bjornsson et al.</p>
<div class="line-block">
<div class="line">1. Modelling Molecular Crystals by QM/MM: Self-Consistent Electrostatic Embedding for Geometry Optimizations and Molecular Property Calculations in the Solid,  R. Bjornsson and M. Bühl,  J. Chem. Theory Comput., 2012, 8, 498-508.</div>
<div class="line">2. R. Bjornsson, manuscript in preparation</div>
</div>
<p>The method allows one to easily incorporate solid-state effects into quantum chemical calculations of molecules via an automatic
QM/MM approach for molecular crystals. The protocol involves read-in of a crystallographic information file (CIF) directly and the
creation of either a spherical cluster or supercell of the molecular crystal. By automatic preparation of a nonbonded forcefield for each
molecular fragment present in the crystal and division of the system into a central active QM-region and a frozen MM environment,
a full-fledged forcefield is not required (typically not available for small molecules, especially coordination complexes).
The method then allows one to do electrostatically embedded QM/MM geometry optimizations, electrostically embedded single-point property calculations
(e.g. NMR, EPR, excited state spectra, Mössbauer etc.) and vibrational spectra via QM/MM numerical frequencies (Currently missing: IR/Raman intensities ).
Minimum energy paths can be calculated and saddle-points (“transition states”) located by a state-of-the-art Nudged Elastic Band
algorithm, available via the Knarr library.</p>
<p>Any QM-code that has an interface in <strong>ASH</strong> can in principle be used for QM/MM geometry optimizations, with any QM-method
within the program (analytical gradient strongly recommended for optimizations).
For the charge-iteration step,  ORCA and xTB are the currently supported QM codes, while all QM codes listed in
<a class="reference internal" href="QM-interfaces.html"><span class="doc">QM Interfaces</span></a> can be used for geometry optimizations.</p>
<a class="reference internal image-reference" href="_images/molcrys-intro-v2a.png"><img alt="_images/molcrys-intro-v2a.png" class="align-center" src="_images/molcrys-intro-v2a.png" style="width: 1200px;" /></a>
<p><strong>The basic automatic protocol:</strong></p>
<div class="line-block">
<div class="line">1. Read CIF-file (or alternative, e.g. Vesta XTL-file) containing fractional coordinates of the cell.</div>
<div class="line">2. Apply symmetry operations to get coordinates for whole unit cell (if needed).</div>
<div class="line">3. Identify the molecular fragments present in cell via connectivity and match with user-input</div>
<div class="line">4. Extend the unit cell and cut out a spherical cluster or supercell with user-defined MM radius (typically 30-50 Å). Only whole molecules included.</div>
<div class="line">5. Define atomic charges of the molecular fragments from QM calculations.</div>
<div class="line">6. Define Lennard-Jones parameters of the molecular fragments.</div>
<div class="line">7. Iterate the atomic charges of the main molecular fragment in the center of the cluster (electrostatically embedded QM/MM) until self-concistency.</div>
<div class="line">8a. Optional: Perform QM/MM geometry optimization of the central fragment or other job types.</div>
<div class="line">8b. Optional: Extend the QM-region around the central fragment for improved accuracy.</div>
<div class="line">8c. Optional: Perform numerical frequency calculations or molecular dynamics simulations.</div>
<div class="line">8d. Optional: Molecular property calculation in the solid-state.</div>
</div>
<p><strong>Critical features of the implementation:</strong></p>
<div class="line-block">
<div class="line">- Handles CIF-files with inconsistent atom ordering by automatic fragment reordering.</div>
<div class="line">- Accuracy can be controlled via QM-region expansion (reduces impact of approximate LJ potentials or MM charges).</div>
<div class="line">- State-of-the-art geometry optimization via efficient internal coordinates (geomeTRIC interface).</div>
<div class="line">- Nudged-elastic-band calculations for reaction-path and TS-optimizations in the solid.</div>
<div class="line">- Numerical frequencies available (to be tested).</div>
</div>
<p><strong>Limitations:</strong></p>
<div class="line-block">
<div class="line">- Polymeric systems or pure solids (e.g. metallic) can not be described. Only system with natural fragmentation such as molecular crystals are possible.</div>
<div class="line">- CIF file can not contain extra atoms such as multiple thermal populations. Also missing H-atoms have to be added beforehand. Use e.g. VESTA, Mercurcy, Chemcraft to inspect CIF-file before. Adding hydrogens to CIF-file can be problematic. Some success has been seen with using Avogadro or Olex2 (others?)</div>
</div>
<p><strong>Features to be implemented:</strong></p>
<div class="line-block">
<div class="line">- Automatic derivation of Lennard-Jones parameters (only UFF forcefield available at the moment).</div>
<div class="line">- Beyond Lennard-Jones potentials for improved QM-MM interaction.</div>
<div class="line">- Molecular dynamics.</div>
<div class="line">- Polarizable embedding</div>
<div class="line">- Proper parallelization of Numerical frequencies.</div>
</div>
<div class="section" id="molcrys-function-creating-a-cluster">
<h2>MOLCRYS function: Creating a cluster<a class="headerlink" href="#molcrys-function-creating-a-cluster" title="Permalink to this headline">¶</a></h2>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="k">def</span> <span class="nf">molcrys</span><span class="p">(</span><span class="n">cif_file</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">xtl_file</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">xyz_file</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">cell_length</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">cell_angles</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
    <span class="n">fragmentobjects</span><span class="o">=</span><span class="p">[],</span> <span class="n">theory</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">numcores</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">chargemodel</span><span class="o">=</span><span class="s1">&#39;&#39;</span><span class="p">,</span> <span class="n">clusterradius</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
    <span class="n">shortrangemodel</span><span class="o">=</span><span class="s1">&#39;UFF_modH&#39;</span><span class="p">,</span> <span class="n">auto_connectivity</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">shiftasymmunit</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">cluster_type</span><span class="o">=</span><span class="s1">&#39;sphere&#39;</span><span class="p">,</span>
    <span class="n">supercell_expansion</span><span class="o">=</span><span class="p">[</span><span class="mi">3</span><span class="p">,</span><span class="mi">3</span><span class="p">,</span><span class="mi">3</span><span class="p">])</span>
</pre></div>
</div>
<p>The purpose of the <strong>molcrys</strong> function is to create a cluster fragment (either spherical or supercell) from a file containing periodic information and to define
a nonbonded MM forcefield for the whole system. The cluster fragment (an ASH fragment) can then be subjected to a QM/MM geometry optimization.
There are 3 inputfile options: cif_file, xtl_file or xyz_file. The CIF-file and XTL-file (created by VESTA) contain fractional coordinates and the unit-cell shape and this is automatically
parsed by ASH. If you provide an XYZ-file then the file must contain real-space coordinates in Å for a whole unitcell and additionally the length and angles of the unitcell have to be provide as well,
using cell_length and cell_angles keywords.</p>
<p>The following keyword arguments must be provided:</p>
<ul class="simple">
<li><p><strong>fragmentobjects</strong>: list of fragment-types</p></li>
<li><p><strong>theory</strong>: ASH QMTheory object</p></li>
<li><p><strong>chargemodel</strong>: String. Which atomchargemodel to use for the nonbonded forcefield. Options: ‘CHELPG’, ‘Hirshfeld’, ‘CM5’, ‘NPA’, ‘Mulliken’.</p></li>
<li><p><strong>shortrangemodel</strong>: String. What model to describe the short-range potential. Currently, the potential is Lennard-Jones with parameter options: ‘UFF_all’, ‘UFF_modH’</p></li>
</ul>
<p>Optional keyword arguments.</p>
<ul class="simple">
<li><p><strong>auto_connectivity</strong>: Boolean(True/False). Whether to figure out the connectivity automatically or not. Default: False</p></li>
<li><p><strong>numcores</strong>: number of cores to use. Default: 1</p></li>
<li><p><strong>cluster_type</strong>: String. Options are: ‘sphere’ and ‘supercell’. Default: ‘sphere’</p></li>
<li><p><strong>clusterradius</strong>: Integer. Radius of cluster sphere. Necessary if cluster_type=’sphere’</p></li>
<li><p><strong>supercell_expansion</strong>: List of integers. How many times to expand the unitcell in x,y,z directions if using cluster_type=’supercell’</p></li>
</ul>
<p><em>Input-file examples:</em></p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="c1">#3 input-file options</span>
<span class="c1"># From CIF-file:</span>
<span class="n">Cluster</span> <span class="o">=</span> <span class="n">molcrys</span><span class="p">(</span><span class="n">cif_file</span><span class="o">=</span><span class="s2">&quot;cif_filename.cif&quot;</span><span class="p">,</span> <span class="n">fragmentobjects</span><span class="o">=</span><span class="p">[</span><span class="n">mainfrag</span><span class="p">,</span><span class="n">counterion</span><span class="p">],</span> <span class="n">theory</span><span class="o">=</span><span class="n">ORCAcalc</span><span class="p">,</span>
    <span class="n">clusterradius</span><span class="o">=</span><span class="mi">32</span><span class="p">,</span> <span class="n">chargemodel</span><span class="o">=</span><span class="s1">&#39;CM5&#39;</span><span class="p">,</span> <span class="n">shortrangemodel</span><span class="o">=</span><span class="s1">&#39;UFF_all&#39;</span><span class="p">)</span>
<span class="c1"># From XTL-file:</span>
<span class="n">Cluster</span> <span class="o">=</span> <span class="n">molcrys</span><span class="p">(</span><span class="n">xtk_file</span><span class="o">=</span><span class="s2">&quot;xtl_filename.xtl&quot;</span><span class="p">,</span> <span class="n">fragmentobjects</span><span class="o">=</span><span class="p">[</span><span class="n">mainfrag</span><span class="p">,</span><span class="n">counterion</span><span class="p">],</span> <span class="n">theory</span><span class="o">=</span><span class="n">ORCAcalc</span><span class="p">,</span>
    <span class="n">clusterradius</span><span class="o">=</span><span class="mi">32</span><span class="p">,</span> <span class="n">chargemodel</span><span class="o">=</span><span class="s1">&#39;CM5&#39;</span><span class="p">,</span> <span class="n">shortrangemodel</span><span class="o">=</span><span class="s1">&#39;UFF&#39;</span><span class="p">)</span>
<span class="c1"># From XYZ-file:</span>
<span class="n">Cluster</span> <span class="o">=</span> <span class="n">molcrys</span><span class="p">(</span><span class="n">xyz_file</span><span class="o">=</span><span class="s2">&quot;xyz_filename.xyz&quot;</span><span class="p">,</span> <span class="n">cell_length</span><span class="o">=</span><span class="p">[</span><span class="mf">10.1</span><span class="p">,</span><span class="mf">12.2</span><span class="p">,</span><span class="mf">10.1</span><span class="p">],</span> <span class="n">cell_angles</span><span class="o">=</span><span class="p">[</span><span class="mi">90</span><span class="p">,</span><span class="mi">90</span><span class="p">,</span><span class="mi">90</span><span class="p">],</span>
    <span class="n">fragmentobjects</span><span class="o">=</span><span class="p">[</span><span class="n">mainfrag</span><span class="p">,</span><span class="n">counterion</span><span class="p">],</span> <span class="n">theory</span><span class="o">=</span><span class="n">ORCAcalc</span><span class="p">,</span>
        <span class="n">clusterradius</span><span class="o">=</span><span class="mi">32</span><span class="p">,</span> <span class="n">chargemodel</span><span class="o">=</span><span class="s1">&#39;CM5&#39;</span><span class="p">,</span> <span class="n">shortrangemodel</span><span class="o">=</span><span class="s1">&#39;UFF&#39;</span><span class="p">)</span>
</pre></div>
</div>
<p><em>Cluster-sphere or supercell examples:</em></p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="c1">#2 types of cluster-shapes (here using CIF-file)</span>
<span class="c1"># Spherical cluster (with 32 Å radius)</span>
<span class="n">Cluster</span> <span class="o">=</span> <span class="n">molcrys</span><span class="p">(</span><span class="n">cif_file</span><span class="o">=</span><span class="s2">&quot;cif_filename.cif&quot;</span><span class="p">,</span> <span class="n">fragmentobjects</span><span class="o">=</span><span class="p">[</span><span class="n">mainfrag</span><span class="p">,</span><span class="n">counterion</span><span class="p">],</span> <span class="n">theory</span><span class="o">=</span><span class="n">ORCAcalc</span><span class="p">,</span>
    <span class="n">clusterradius</span><span class="o">=</span><span class="mi">32</span><span class="p">,</span> <span class="n">chargemodel</span><span class="o">=</span><span class="s1">&#39;CM5&#39;</span><span class="p">,</span> <span class="n">shortrangemodel</span><span class="o">=</span><span class="s1">&#39;UFF_all&#39;</span><span class="p">)</span>
<span class="c1"># 3x3x3 Supercell</span>
<span class="n">Cluster</span> <span class="o">=</span> <span class="n">molcrys</span><span class="p">(</span><span class="n">cif_file</span><span class="o">=</span><span class="s2">&quot;cif_filename.cif&quot;</span><span class="p">,</span> <span class="n">fragmentobjects</span><span class="o">=</span><span class="p">[</span><span class="n">mainfrag</span><span class="p">,</span><span class="n">counterion</span><span class="p">],</span> <span class="n">theory</span><span class="o">=</span><span class="n">ORCAcalc</span><span class="p">,</span>
    <span class="n">cluster_type</span><span class="o">=</span><span class="s1">&#39;supercell&#39;</span><span class="p">,</span> <span class="n">supercell_expansion</span><span class="o">=</span><span class="p">[</span><span class="mi">3</span><span class="p">,</span><span class="mi">3</span><span class="p">,</span><span class="mi">3</span><span class="p">],</span> <span class="n">chargemodel</span><span class="o">=</span><span class="s1">&#39;CM5&#39;</span><span class="p">,</span> <span class="n">shortrangemodel</span><span class="o">=</span><span class="s1">&#39;UFF_all&#39;</span><span class="p">)</span>
</pre></div>
</div>
</div>
<div class="section" id="molcrys-example-spherical-qm-mm-cluster-setup-from-cif-file">
<h2>MOLCRYS Example: Spherical QM/MM Cluster setup from CIF-file<a class="headerlink" href="#molcrys-example-spherical-qm-mm-cluster-setup-from-cif-file" title="Permalink to this headline">¶</a></h2>
<p>Here we show how to use the <strong>MOLCRYS</strong> code for an example Na<sup>+</sup> [H<sub>2</sub>PO<sub>4</sub>] <sup>-</sup> crystal. This molecular crystal contains 2 fragment-types:
Na<sup>+</sup> and H<sub>2</sub>PO<sub>4</sub><sup>-</sup> </p>
<p><a class="reference external" href="https://www.ccdc.cam.ac.uk/structures/Search?Ccdcid=ICSD%20200885&amp;DatabaseToSearch=Published">CIF-file download.</a></p>
<a class="reference internal image-reference" href="_images/nah2po4-cell.png"><img alt="_images/nah2po4-cell.png" class="align-center" src="_images/nah2po4-cell.png" style="width: 600px;" /></a>
<p>Here we will only do the cluster setup and the charge-iteration.
A Python script should be created and then the <strong>ASH</strong> and MOLCRYS modules should be imported.</p>
<p>The script should then just call one function, called <strong>molcrys</strong> at the bottom of the script:</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="n">Cluster</span> <span class="o">=</span> <span class="n">molcrys</span><span class="p">(</span><span class="n">cif_file</span><span class="o">=</span><span class="n">cif_file</span><span class="p">,</span> <span class="n">fragmentobjects</span><span class="o">=</span><span class="n">fragmentobjects</span><span class="p">,</span> <span class="n">theory</span><span class="o">=</span><span class="n">ORCAcalc</span><span class="p">,</span>
    <span class="n">numcores</span><span class="o">=</span><span class="n">numcores</span><span class="p">,</span> <span class="n">clusterradius</span><span class="o">=</span><span class="n">sphereradius</span><span class="p">,</span> <span class="n">chargemodel</span><span class="o">=</span><span class="n">chargemodel</span><span class="p">,</span> <span class="n">shortrangemodel</span><span class="o">=</span><span class="n">shortrangemodel</span><span class="p">)</span>
</pre></div>
</div>
<p>Calling <strong>molcrys</strong> will create the cluster and return a Cluster object that can be used directly (also written to disk).
This is the only function of this script but as we can see, there are a number of keyword arguments, with values that
are variables of multiple types.
It is usually more convenient to define first the necessary variables in multiple lines above this command.
In the full script, seen below, a number of variables are defined, following standard Python syntax.</p>
<p><strong>ASH</strong>-specific variables is the creation of the ORCAcalc object (instance of the <strong>ASH</strong> ORCATheory class),
the creation of mainfrag and counterfrag1 objects (instances of <strong>ASH</strong> Fragmenttype class).
The variables are then passed as keyword arguments to the  <strong>molcrys</strong> function at the bottom of the script.</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="kn">from</span> <span class="nn">ash</span> <span class="kn">import</span> <span class="o">*</span>
<span class="kn">from</span> <span class="nn">molcrys</span> <span class="kn">import</span> <span class="o">*</span>
<span class="n">settings_ash</span><span class="o">.</span><span class="n">init</span><span class="p">()</span>
<span class="c1">#######################</span>
<span class="c1"># MOLCRYS INPUT          #</span>
<span class="c1">#######################</span>
<span class="n">cif_file</span><span class="o">=</span><span class="s2">&quot;nah2po4_choudhary1981.cif&quot;</span>
<span class="n">sphereradius</span><span class="o">=</span><span class="mi">35</span>

<span class="c1">#Number of cores available to ASH. Used by QM-code or ASH.</span>
<span class="n">numcores</span><span class="o">=</span><span class="mi">12</span>

<span class="c1">#Theory level for charge iterations</span>
<span class="n">orcadir</span><span class="o">=</span><span class="s1">&#39;/opt/orca_4.2.1&#39;</span>
<span class="n">orcasimpleinput</span><span class="o">=</span><span class="s2">&quot;! BP86 def2-SVP def2/J Grid5 Finalgrid6 tightscf&quot;</span>
<span class="n">orcablocks</span><span class="o">=</span><span class="s2">&quot;</span><span class="si">%s</span><span class="s2">cf maxiter 200 end&quot;</span>
<span class="n">ORCAcalc</span> <span class="o">=</span> <span class="n">ORCATheory</span><span class="p">(</span><span class="n">orcadir</span><span class="o">=</span><span class="n">orcadir</span><span class="p">,</span> <span class="n">orcasimpleinput</span><span class="o">=</span><span class="n">orcasimpleinput</span><span class="p">,</span> <span class="n">orcablocks</span><span class="o">=</span><span class="n">orcablocks</span><span class="p">,</span> <span class="n">nprocs</span><span class="o">=</span><span class="n">numcores</span><span class="p">)</span>

<span class="c1">#Chargemodel. Options: CHELPG, Hirshfeld, CM5, NPA, Mulliken</span>
<span class="n">chargemodel</span><span class="o">=</span><span class="s1">&#39;Hirshfeld&#39;</span>
<span class="c1">#Shortrange model. Usually Lennard-Jones. Options: UFF_all, UFF_modH</span>
<span class="n">shortrangemodel</span><span class="o">=</span><span class="s1">&#39;UFF_modH&#39;</span>

<span class="c1">#Define fragment types in crystal: Descriptive name, formula, charge and multiplicity</span>
<span class="n">mainfrag</span> <span class="o">=</span> <span class="n">Fragmenttype</span><span class="p">(</span><span class="s2">&quot;Phosphate&quot;</span><span class="p">,</span><span class="s2">&quot;PO4H2&quot;</span><span class="p">,</span> <span class="n">charge</span><span class="o">=-</span><span class="mi">1</span><span class="p">,</span><span class="n">mult</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
<span class="n">counterfrag1</span> <span class="o">=</span> <span class="n">Fragmenttype</span><span class="p">(</span><span class="s2">&quot;Sodium&quot;</span><span class="p">,</span><span class="s2">&quot;Na&quot;</span><span class="p">,</span> <span class="n">charge</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span><span class="n">mult</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
<span class="c1">#Define list of fragmentobjects. Passed on to molcrys</span>
<span class="n">fragmentobjects</span><span class="o">=</span><span class="p">[</span><span class="n">mainfrag</span><span class="p">,</span><span class="n">counterfrag1</span><span class="p">]</span>

<span class="c1">#Modify global connectivity settings (scale and tol keywords)</span>
<span class="n">settings_ash</span><span class="o">.</span><span class="n">scale</span><span class="o">=</span><span class="mf">1.0</span>
<span class="n">settings_ash</span><span class="o">.</span><span class="n">tol</span><span class="o">=</span><span class="mf">0.3</span>
<span class="c1"># Modified radii to assist with connectivity.</span>
<span class="c1">#Setting radius of Na to almost 0. Na will then not bond</span>
<span class="n">eldict_covrad</span><span class="p">[</span><span class="s1">&#39;Na&#39;</span><span class="p">]</span><span class="o">=</span><span class="mf">0.0001</span>
<span class="nb">print</span><span class="p">(</span><span class="n">eldict_covrad</span><span class="p">)</span>


<span class="c1">#Calling molcrys function and define Cluster object</span>
<span class="n">Cluster</span> <span class="o">=</span> <span class="n">molcrys</span><span class="p">(</span><span class="n">cif_file</span><span class="o">=</span><span class="n">cif_file</span><span class="p">,</span> <span class="n">fragmentobjects</span><span class="o">=</span><span class="n">fragmentobjects</span><span class="p">,</span> <span class="n">theory</span><span class="o">=</span><span class="n">ORCAcalc</span><span class="p">,</span> <span class="n">auto_connectivity</span><span class="o">=</span><span class="kc">True</span>
        <span class="n">numcores</span><span class="o">=</span><span class="n">numcores</span><span class="p">,</span> <span class="n">clusterradius</span><span class="o">=</span><span class="n">sphereradius</span><span class="p">,</span> <span class="n">chargemodel</span><span class="o">=</span><span class="n">chargemodel</span><span class="p">,</span> <span class="n">shortrangemodel</span><span class="o">=</span><span class="n">shortrangemodel</span><span class="p">)</span>
</pre></div>
</div>
<p>We point to the CIF file (should be present in same directory as script) that should be read and define a sphereradius. We also define the number of cores available
(should later match that defined in the job-submission script), that both ORCA and <strong>ASH</strong> may use in their parallelization.
Next, an ORCA theory object is defined where we set the path to ORCA and define the structure of the inputfile used
when running ORCA calculations.</p>
<p>The chargemodel and shortrangemodel variables are used to define keywords that <strong>molcrys</strong> will recognize.
The chargemodel defines how to derive the pointcharges for the MM cluster for the QM-MM electrostatic interaction. Available chargemodels are: CHELPG, Hirshfeld, CM5, NPA, Mulliken</p>
<p>The shortrangemodel defines the short-range interactions between QM and MM atoms (other than the electrostatic).
Currently, only the UFF Lennard-Jones model is available that uses element-specific parameters (from the Universal Forcefield, UFF) to set up Lennard-Jones potentials between
all atoms. The “UFF_modH” keyword is currently recommended that uses available parameters for all elements except the LJ
parameters for H are set to zero to avoid artificial repulsion for acidic H-atoms.</p>
<p>Next, we have to define the fragments present in the crystal. In the future, this may become more automated.
Thus, we define a fragment, called <em>mainfrag</em>, that is our primary interest. Here, this is the H<sub>2</sub>PO<sub>4</sub><sup>-</sup> anion, while the counterion Na<sup>+</sup> ion is of less interest, here labelled <em>counterfrag1</em>.
This distinction between fragments means that the <em>mainfrag</em> will be at the center of the cluster and charge-iterations are currently only
performed for <em>mainfrag</em>.
It also means that the charge-iterations are only performed for <em>mainfrag</em>.
For each molecular fragment, we define an object of class Fragmenttype with a name e.g. “Phosphate”,
elemental formula, e.g. “PO4H2”, and define the charge and multiplicity of that fragment.
The elemental formula is crucial as from the formula the total nuclear charge is calculated which is used to identify these
fragments in the molecular crystal. Once the fragments are defined we group them together in the following order as a list
called fragmentobjects:     fragmentobjects=[mainfrag,counterfrag1]</p>
<p>Finally, the script shows how the connectivity can be modified in order for the fragment identification to succeed.
The fragment identification works by finding what atoms are connected according to the formula:</p>
<div class="math notranslate nohighlight">
\[r(AtomA,AtomB) &lt; scale*( covrad(AtomA) + covrad(AtomB) ) + tol\]</div>
<p>Thus, if the distance between atoms A and B is less than the sum of the elemental covalent radii
(which can be scaled by a parameter scale or shifted by a parameter tol) then the atoms are connected.
Using default parameters of the element radii (Alvarez 2008), the default scaling of 1.0 and a tolerance of 0.1
(global scale and tol parameters are defined in settings_ash file) works in many cases.
For the Na<sup>+</sup> [H<sub>2</sub>PO<sub>4</sub>] <sup>-</sup> crystal, however, that features strong hydrogen-bonding and the ionic Na<sup>+</sup> fragment, we have to make some modifications.
In the script above, we thus have to set the tol parameter to 0.3 and change the radius of the Na<sup>+</sup> ion to a small value.
The covalent radii of the elements are stored in a global Python dictionary, eldict_covrad which can be easily modified as shown
and its contents printed. In the future, the radius of the Na may by default be set to a small number.</p>
<p>Unlike the other variables, the <em>settings_ash.scale</em>, <em>settings_ash.tol</em> and <em>eldict_covrad</em> are
global variables (already defined but can be modified) that <strong>molcrys</strong> and <strong>ASH</strong> will have access to.</p>
<p>June 2020: New Automatic Connectivity feature: auto_connectivity=True.
When this feature is used, Molcrys scans through different tolerances (0.1 to 0.7 in 0.1 steps) until it finds a connectivity that gives complete assignment.
This feature should work most of the time.</p>
<p>The other variables defined in the script have to be passed as values to the respective keyword arguments of
the <strong>molcrys</strong> function:</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="n">Cluster</span> <span class="o">=</span> <span class="n">molcrys</span><span class="p">(</span><span class="n">cif_file</span><span class="o">=</span><span class="n">cif_file</span><span class="p">,</span> <span class="n">fragmentobjects</span><span class="o">=</span><span class="n">fragmentobjects</span><span class="p">,</span> <span class="n">theory</span><span class="o">=</span><span class="n">ORCAcalc</span><span class="p">,</span> <span class="n">auto_connectivity</span><span class="o">=</span><span class="kc">True</span>
    <span class="n">numcores</span><span class="o">=</span><span class="n">numcores</span><span class="p">,</span> <span class="n">clusterradius</span><span class="o">=</span><span class="n">sphereradius</span><span class="p">,</span> <span class="n">chargemodel</span><span class="o">=</span><span class="n">chargemodel</span><span class="p">,</span> <span class="n">shortrangemodel</span><span class="o">=</span><span class="n">shortrangemodel</span><span class="p">)</span>
</pre></div>
</div>
<p>These are currently the only arguments that can be provided to the <strong>molcrys</strong> function, with the exception that
instead of a <em>cif_file</em> argument, an <em>xtl_file</em> argument can alternatively be provided where the name of the XTL-file should
be passed on instead. An XTL-file can be created by the Vesta software (<a class="reference external" href="http://jp-minerals.org/vesta/en/">http://jp-minerals.org/vesta/en/</a>).</p>
<p>The purpose of the molcrys function is primarily to create an <strong>ASH</strong> cluster-fragment, here called Cluster. The Cluster fragment
will contain the coordinates of the spherical MM cluster with charges from the self-consistent QM procedure and atom-types
defined via the shortrange model procedure chosen. The Cluster fragment is both present in memory once defined (i.e. the molcrys function has finished)
and is also written to disk as: Cluster.ygg. A forcefield file is also created by <strong>molcrys</strong>: Cluster_forcefield.ff, that contains
the Lennard-Jones parameters defined for the atomtypes that have been chosen for every atom in the Cluster fragment.</p>
<p>Typically running the <strong>molcrys</strong> function takes only a few minutes, depending on the size of the molecular fragments
and the size of the Cluster radius but usually it is easiest to submit this to the cluster to run the QM calculations in parallel.
If the connectivity requires modifications, however, then first running through the script directly (on a local
computer or frontnode of the cluster) may be easier.</p>
<p>The Cluster fragment file, Cluster.ygg, can be used directly in a single-point property job (see later).
If using the ORCA interface, the last orca-input.inp and orca-input.pc files created by <strong>molcrys</strong>
can also directly be used to run a single-point electrostatically-embedded property calculation with ORCA
(note: not a geometry optimization though) as they contain the QM-coordinates of the central fragment (orca-input.inp) and
the MM coordinates and self-consistent pointcharges (orca-input.pc).</p>
</div>
<div class="section" id="molcrys-qm-mm-geometry-optimization">
<h2>MOLCRYS: QM/MM Geometry optimization<a class="headerlink" href="#molcrys-qm-mm-geometry-optimization" title="Permalink to this headline">¶</a></h2>
<p>To run a QM/MM geometry optimization, this can be done separately by preparing a regular <strong>ASH</strong> QM/MM inputfile and read in
the Cluster fragment file and the forcefield file, Cluster_forcefield.ff.
It is often more convenient to continue with a QM/MM geometry optimization in the same script, after the <strong>molcrys</strong> function.
In that case, the code below can simply be appended to the previous script.</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="c1">#Once molcrys is done we have a Cluster object (named Cluster) in memory and also printed to disk as Cluster.ygg</span>
<span class="c1"># We can then do optimization right here using that Cluster object.</span>
<span class="c1">#Alternatively or for restart purposes we can read a Cluster object into a separate QM/MM Opt job like this:</span>
<span class="c1">#Cluster=Fragment(fragfile=&#39;Cluster.ygg&#39;)</span>
<span class="nb">print</span><span class="p">(</span><span class="s2">&quot;Now Doing Optimization&quot;</span><span class="p">)</span>

<span class="c1"># Defining Centralmainfrag (a list of atoms) for optimization. Can be done in multiple ways:</span>
<span class="c1">#Centralmainfrag=fragmentobjects[0].clusterfraglist[0]</span>
<span class="c1">#Read list of atom indices from file (created by molcrys): Centralmainfrag = read_intlist_from_file(&quot;Centralmainfrag&quot;)</span>
<span class="c1">#Can also be done manually: Centralmainfrag=[0, 1, 5, 8, 9, 12, 14]</span>
<span class="c1">#Easiest way:</span>
<span class="n">Centralmainfrag</span> <span class="o">=</span> <span class="n">Cluster</span><span class="o">.</span><span class="n">Centralmainfrag</span>
<span class="nb">print</span><span class="p">(</span><span class="s2">&quot;Centralmainfrag:&quot;</span><span class="p">,</span> <span class="n">Centralmainfrag</span><span class="p">)</span>

<span class="n">charge</span><span class="o">=</span><span class="n">fragmentobjects</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">Charge</span>
<span class="n">mult</span><span class="o">=</span><span class="n">fragmentobjects</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">Mult</span>
<span class="c1">#</span>
<span class="n">Cluster_FF</span><span class="o">=</span><span class="n">MMforcefield_read</span><span class="p">(</span><span class="s1">&#39;Cluster_forcefield.ff&#39;</span><span class="p">)</span>

<span class="c1">#Defining, QM, MM and QM/MM theory levels for Optimization</span>
<span class="c1">#If same theory as used in molcrys, then orcadir, orcasimpleinput and orcablocks can be commented out/deleted.</span>
<span class="n">orcadir</span><span class="o">=</span><span class="s1">&#39;/opt/orca_4.2.1&#39;</span>
<span class="n">orcasimpleinput</span><span class="o">=</span><span class="s2">&quot;! BP86 def2-SVP def2/J Grid5 Finalgrid6 tightscf&quot;</span>
<span class="n">orcablocks</span><span class="o">=</span><span class="s2">&quot;</span><span class="si">%s</span><span class="s2">cf maxiter 200 end&quot;</span>
<span class="n">ORCAQMpart</span> <span class="o">=</span> <span class="n">ORCATheory</span><span class="p">(</span><span class="n">orcadir</span><span class="o">=</span><span class="n">orcadir</span><span class="p">,</span> <span class="n">charge</span><span class="o">=</span><span class="n">charge</span><span class="p">,</span> <span class="n">mult</span><span class="o">=</span><span class="n">mult</span><span class="p">,</span> <span class="n">orcasimpleinput</span><span class="o">=</span><span class="n">orcasimpleinput</span><span class="p">,</span> <span class="n">orcablocks</span><span class="o">=</span><span class="n">orcablocks</span><span class="p">)</span>
<span class="n">MMpart</span> <span class="o">=</span> <span class="n">NonBondedTheory</span><span class="p">(</span><span class="n">charges</span> <span class="o">=</span> <span class="n">Cluster</span><span class="o">.</span><span class="n">atomcharges</span><span class="p">,</span> <span class="n">atomtypes</span><span class="o">=</span><span class="n">Cluster</span><span class="o">.</span><span class="n">atomtypes</span><span class="p">,</span> <span class="n">forcefield</span><span class="o">=</span><span class="n">Cluster_FF</span><span class="p">,</span> <span class="n">LJcombrule</span><span class="o">=</span><span class="s1">&#39;geometric&#39;</span><span class="p">)</span>
<span class="n">QMMM_object</span> <span class="o">=</span> <span class="n">QMMMTheory</span><span class="p">(</span><span class="n">fragment</span><span class="o">=</span><span class="n">Cluster</span><span class="p">,</span> <span class="n">qm_theory</span><span class="o">=</span><span class="n">ORCAQMpart</span><span class="p">,</span> <span class="n">mm_theory</span><span class="o">=</span><span class="n">MMpart</span><span class="p">,</span> <span class="n">actatoms</span><span class="o">=</span><span class="n">Centralmainfrag</span><span class="p">,</span>
    <span class="n">qmatoms</span><span class="o">=</span><span class="n">Centralmainfrag</span><span class="p">,</span> <span class="n">charges</span><span class="o">=</span><span class="n">Cluster</span><span class="o">.</span><span class="n">atomcharges</span><span class="p">,</span> <span class="n">embedding</span><span class="o">=</span><span class="s1">&#39;Elstat&#39;</span><span class="p">,</span> <span class="n">nprocs</span><span class="o">=</span><span class="n">numcores</span><span class="p">)</span>


<span class="n">geomeTRICOptimizer</span><span class="p">(</span><span class="n">theory</span><span class="o">=</span><span class="n">QMMM_object</span><span class="p">,</span> <span class="n">fragment</span><span class="o">=</span><span class="n">Cluster</span><span class="p">,</span> <span class="n">coordsystem</span><span class="o">=</span><span class="s1">&#39;tric&#39;</span><span class="p">,</span> <span class="n">maxiter</span><span class="o">=</span><span class="mi">170</span><span class="p">,</span> <span class="n">ActiveRegion</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">actatoms</span><span class="o">=</span><span class="n">Centralmainfrag</span> <span class="p">)</span>
</pre></div>
</div>
<p>We define a variable Centralmainfrag as the list of atoms that should be both described at the QM level (will be passed to qmatoms keyword argument)
and should be optimized in a geometry optimization (passed to actatoms of optimizer ). This list may also be a larger QM-cluster, e.g. multiple H2PO4 units or with Na+ included.</p>
<p>The charge and multiplicity of the molecule is then defined and a forcefield object is defined by reading in the ‘Cluster_forcefield.ff’
forcefield file, previously created by the <strong>molcrys</strong> function.</p>
<p>Next we have to define a QM/MM object by combining a QM-theory object (here of class ORCATheory) and an MM theory object (of class NonBondedTheory).
See QM/MM theory page for more information on this. Note that actatoms is defined here as well as this means that the internal MM energy of the frozen MM region can be skipped.</p>
<p>Finally we call the optimizer program, here the geomeTRICoptimizer:</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="n">geomeTRICOptimizer</span><span class="p">(</span><span class="n">theory</span><span class="o">=</span><span class="n">QMMM_object</span><span class="p">,</span> <span class="n">fragment</span><span class="o">=</span><span class="n">Cluster</span><span class="p">,</span> <span class="n">coordsystem</span><span class="o">=</span><span class="s1">&#39;tric&#39;</span><span class="p">,</span> <span class="n">maxiter</span><span class="o">=</span><span class="mi">170</span><span class="p">,</span> <span class="n">ActiveRegion</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">actatoms</span><span class="o">=</span><span class="n">Centralmainfrag</span> <span class="p">)</span>
</pre></div>
</div>
<p>We provide a theory argument to the optimizer (our QM/MM object), the Cluster fragment, we specify the coordinate
system (here the TRIC internal coordinates are used), max no. of iterations may be provided and finally we specify that we have an active region
and that only the atoms provided to the actatoms keyword argument should be optimized. Note that MM atoms can not be optimized when
doing nonbonded QM/MM like we are doing here. If the optimization converges, a new fragment containing the optimized geometry is provided, called “Fragment-optimized.ygg”.</p>
<p>Note: Only the geometry of the central fragment (or whatever qmatoms/actoms was set to) is optimized. The other atoms
are still at the original positions as determined from the crystal structure.
The optimization trajectory is also available as a multi-structure XYZ file, as either “geometric_OPTtraj_Full.xyz”
(Full system) or “geometric_OPTtraj.xyz” (Act-region only).</p>
<p>Note: To restart a geometry optimization of the cluster it is best to locate the file “Fragment-currentgeo.ygg” (written and updated in each optimization step)
and use this to restart a QM/MM geometry optimization. This file contains coordinates for the whole system but with updated coordinates for the active region
and the previously optimized charges.</p>
<p>Note:
If the optimization is done separately, the code above would have to be manually changed in a few places.
First the Cluster fragment would be read in:</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="n">Cluster</span><span class="o">=</span><span class="n">Fragment</span><span class="p">(</span><span class="n">fragfile</span><span class="o">=</span><span class="s1">&#39;Cluster.ygg&#39;</span><span class="p">)</span>
</pre></div>
</div>
<p>One would then manually define variables charge, mult (of the main fragment) as <em>fragmentobjects</em> would not be available.</p>
</div>
<div class="section" id="molcrys-expanded-qm-region-calculation">
<h2>MOLCRYS: Expanded QM region calculation<a class="headerlink" href="#molcrys-expanded-qm-region-calculation" title="Permalink to this headline">¶</a></h2>
<p>For either a QM/MM geometry optimization or a QM/MM single-point property calculation (see below), the QM-region does
not have to be a single fragment. If the qmatoms list and the actatoms list (for optimizations) is modified, then a larger
QM cluster can be calculated instead in the QM/MM calculation: e.g. metalcomplex + counterion or a metalcomplex dimer.
This should generally result in a more accurate calculation as the QM-MM boundary effect can be reduced.
Hydrogen-bonding between fragments would particularly benefit from this as this is a strong noncovalent interaction.</p>
<p>The qmatoms and actatoms lists (i.e. the values provided to qmatoms and actatoms keyword arguments to QM/MM object or
geomeTRICOptimizer function can be modified manually, e.g. by visually inspecting an XYZ-file version of the Cluster and
provide the correct list of atom indices (Note: <strong>ASH</strong> counts from zero).</p>
<p>More conveniently, the QMregionfragexpand function can be used to find nearby atoms for an initial list of atoms.</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="n">Centralmainfrag</span> <span class="o">=</span> <span class="n">read_intlist_from_file</span><span class="p">(</span><span class="s2">&quot;Centralmainfrag&quot;</span><span class="p">)</span>
<span class="n">expanded_central_region</span> <span class="o">=</span> <span class="n">QMregionfragexpand</span><span class="p">(</span><span class="n">fragment</span><span class="o">=</span><span class="n">Cluster</span><span class="p">,</span><span class="n">initial_atoms</span><span class="o">=</span><span class="n">Centralmainfrag</span><span class="p">,</span> <span class="n">radius</span><span class="o">=</span><span class="mi">3</span><span class="p">)</span>
</pre></div>
</div>
<p>In the code example above, a new variable called “expanded_central_region” is defined that contains a new list of atoms containing
whole fragments that are 3 Å away from the central mainfrag.
This expanded_central_region list can then be fed to qmatoms and actatoms keyword arguments in either a QM/MM optimization
job or a single-point property job.
The radius variable would have to be tweaked and the result inspected to get appropriately sized and shaped QM-clusters.</p>
<p><strong>Note:</strong> The charge and multiplicity keywords probably need to be changed for the new QM-cluster calculations.</p>
<p>TODO: Create standalone QMregionfragexpand script.</p>
</div>
<div class="section" id="molcrys-property-calculation">
<h2>MOLCRYS: Property calculation<a class="headerlink" href="#molcrys-property-calculation" title="Permalink to this headline">¶</a></h2>
<p>A QM/MM molecular/spectroscopic property calculations can be carried either using <strong>ASH</strong> or using the QM program directly.
If using ORCA, the appropriate property keywords can be added to orcasimpleinput or orcablocks variables in <strong>ASH</strong> that will be passed onto ORCA.</p>
<p>A single-point QM/MM calculation can be performed by defining a QM/MM object as done before and then pass the QM/MM object and the cluster fragment
object to the Singlepoint function. Make sure to specify the desired Cluster object: e.g. the original Cluster or the Cluster file from the QM/MM optimization (contains optimized coordinates for the central fragment).</p>
<p>Script below shows an example electrostatically embedded NMR calculation using ORCA:</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="kn">from</span> <span class="nn">ash</span> <span class="kn">import</span> <span class="o">*</span>
<span class="n">settings_ash</span><span class="o">.</span><span class="n">init</span><span class="p">()</span>

<span class="c1">#Read in Cluster fragment</span>
<span class="n">Cluster</span><span class="o">=</span><span class="n">Fragment</span><span class="p">(</span><span class="n">fragfile</span><span class="o">=</span><span class="s1">&#39;Cluster.ygg&#39;</span><span class="p">)</span>

<span class="c1"># Defining Centralmainfrag (list of atoms) for optimization</span>
<span class="n">Centralmainfrag</span> <span class="o">=</span> <span class="n">read_intlist_from_file</span><span class="p">(</span><span class="s2">&quot;Centralmainfrag&quot;</span><span class="p">)</span>
<span class="c1">#Can also be done manually</span>
<span class="c1">#Centralmainfrag=[0, 1, 5, 8, 9, 12, 14]</span>
<span class="nb">print</span><span class="p">(</span><span class="s2">&quot;Centralmainfrag:&quot;</span><span class="p">,</span> <span class="n">Centralmainfrag</span><span class="p">)</span>

<span class="c1">#Can also be done done manually if fragmentobjects not available, e.g. charge=-1, mult=1</span>
<span class="n">charge</span><span class="o">=-</span><span class="mi">1</span>
<span class="n">mult</span><span class="o">=</span><span class="mi">1</span>

<span class="c1">#Reading in force-field file</span>
<span class="n">Cluster_FF</span><span class="o">=</span><span class="n">MMforcefield_read</span><span class="p">(</span><span class="s1">&#39;Cluster_forcefield.ff&#39;</span><span class="p">)</span>

<span class="c1">#Defining, QM, MM and QM/MM theory levels for Optimization</span>
<span class="c1">#ORCAlines: If same theory as used in molcrys, then orcadir, orcasimpleinput and orcablocks can be commented out/deleted.</span>
<span class="n">numcores</span><span class="o">=</span><span class="mi">12</span>
<span class="n">orcadir</span><span class="o">=</span><span class="s1">&#39;/opt/orca_4.2.1&#39;</span>
<span class="n">orcasimpleinput</span><span class="o">=</span><span class="s2">&quot;! PBE0 def2-SVP def2/J Grid5 Finalgrid6 tightscf NMR&quot;</span>
<span class="n">orcablocks</span><span class="o">=</span><span class="s2">&quot;</span>
<span class="o">%</span><span class="n">scf</span> <span class="n">maxiter</span> <span class="mi">200</span> <span class="n">end</span>
<span class="o">%</span><span class="n">eprnmr</span>
<span class="n">Nuclei</span> <span class="o">=</span> <span class="nb">all</span> <span class="n">B</span> <span class="p">{</span> <span class="n">shift</span> <span class="p">}</span>
<span class="n">Nuclei</span> <span class="o">=</span> <span class="nb">all</span> <span class="n">C</span> <span class="p">{</span> <span class="n">shift</span> <span class="p">}</span>
<span class="n">end</span>
<span class="s2">&quot;</span>
<span class="n">ORCAQMpart</span> <span class="o">=</span> <span class="n">ORCATheory</span><span class="p">(</span><span class="n">orcadir</span><span class="o">=</span><span class="n">orcadir</span><span class="p">,</span> <span class="n">charge</span><span class="o">=</span><span class="n">charge</span><span class="p">,</span> <span class="n">mult</span><span class="o">=</span><span class="n">mult</span><span class="p">,</span> <span class="n">orcasimpleinput</span><span class="o">=</span><span class="n">orcasimpleinput</span><span class="p">,</span> <span class="n">orcablocks</span><span class="o">=</span><span class="n">orcablocks</span><span class="p">)</span>
<span class="n">MMpart</span> <span class="o">=</span> <span class="n">NonBondedTheory</span><span class="p">(</span><span class="n">charges</span> <span class="o">=</span> <span class="n">Cluster</span><span class="o">.</span><span class="n">atomcharges</span><span class="p">,</span> <span class="n">atomtypes</span><span class="o">=</span><span class="n">Cluster</span><span class="o">.</span><span class="n">atomtypes</span><span class="p">,</span> <span class="n">forcefield</span><span class="o">=</span><span class="n">Cluster_FF</span><span class="p">,</span> <span class="n">LJcombrule</span><span class="o">=</span><span class="s1">&#39;geometric&#39;</span><span class="p">)</span>
<span class="n">QMMM_object</span> <span class="o">=</span> <span class="n">QMMMTheory</span><span class="p">(</span><span class="n">fragment</span><span class="o">=</span><span class="n">Cluster</span><span class="p">,</span> <span class="n">qm_theory</span><span class="o">=</span><span class="n">ORCAQMpart</span><span class="p">,</span> <span class="n">mm_theory</span><span class="o">=</span><span class="n">MMpart</span><span class="p">,</span>
    <span class="n">qmatoms</span><span class="o">=</span><span class="n">Centralmainfrag</span><span class="p">,</span> <span class="n">charges</span><span class="o">=</span><span class="n">Cluster</span><span class="o">.</span><span class="n">atomcharges</span><span class="p">,</span> <span class="n">embedding</span><span class="o">=</span><span class="s1">&#39;Elstat&#39;</span><span class="p">,</span> <span class="n">nprocs</span><span class="o">=</span><span class="n">numcores</span><span class="p">)</span>

<span class="n">Singlepoint</span><span class="p">(</span><span class="n">fragment</span><span class="o">=</span><span class="n">Cluster</span><span class="p">,</span> <span class="n">theory</span><span class="o">=</span><span class="n">QMMM_object</span><span class="p">)</span>
</pre></div>
</div>
<p>Alternatively (sometimes easier), the last ORCA inputfile (orca-input.pc) and pointcharge file (orca-input.pc) from either <strong>molcrys</strong>
or the optimization can be used to run a single-point property job using ORCA directly. If the inputfile came from the optimization job then it contains
optimized QM coordinates and the pointcharge-file should contain the self-consistently determined pointcharges for the full cluster.
Thus a simple modification to the inputfile would only be required to run a property job using all functionality available in ORCA.</p>
</div>
<div class="section" id="molcrys-reaction-path-and-saddle-point-finding-via-neb-method">
<h2>MOLCRYS: Reaction path and saddle-point finding via NEB method<a class="headerlink" href="#molcrys-reaction-path-and-saddle-point-finding-via-neb-method" title="Permalink to this headline">¶</a></h2>
<p>Due to an interface to the Knarr program, NEB calculations (see <a class="reference internal" href="job-types.html"><span class="doc">Job Types</span></a> for general info) can easily be performed in <strong>ASH</strong>.
This is even possible for a QM/MM Hamiltonian and for a molecular crystal system like here.
The purpose of an NEB job is typically to locate the saddlepoint connecting a reactant and product while partially converging the minimum
energy path between.</p>
<p>Note that in the MOLCRYS approach , only the cental fragment is actually optimized, all other molecules in the cluster remain in their original
positions (i.e. from the CIF-file). Same approximation applies to reaction paths.</p>
<p>Starting from a geometry-optimized fragment (as done above) that we will call our reactant state, we first need to optimize a product state.</p>
<p><strong>1. Locating product</strong></p>
<p>Starting from an Ash fragment file, here called reactant.ygg, we want to modify the coordinates of the central fragment
(previously optimized for reactant state).
Let’s first create a copy of the fragment file:</p>
<div class="highlight-shell notranslate"><div class="highlight"><pre><span></span>cp reactant.ygg product.ygg
</pre></div>
</div>
<p>The fragment file product.ygg will be modified.
We use the fragedit script (located in scripts directory of Ash):</p>
<div class="highlight-shell notranslate"><div class="highlight"><pre><span></span>python3 fragedit.py product.ygg
</pre></div>
</div>
<p>The script assumes the presence of a file called “qmatoms” that contains a list of atom indices that are the QM atoms.
Alternatively the name of the file can be specified as a second argument. The list of atom indices should be taken from the previous molcrys job.
fragedit.py creates an XYZ file named “fragment.xyz”. This file can be visualized in e.g. Chemcraft and the coordinates can be modified.
Here we will change the coordinates to reflect the desired product state. Once done, the coordinates are pasted back to the file “fragment.xyz”.</p>
<p>To update the Ash fragment file we need to run a script called fragupdate.py:</p>
<div class="highlight-shell notranslate"><div class="highlight"><pre><span></span>fragupdate.py product.ygg
</pre></div>
</div>
<p>fragupdate.py also relies on a file “qmatoms” being present in the same directory or alternatively another file can be passed as 2nd argument.
This will update the file product.ygg using the modified coordinates in fragment.xyz. To confirm that product.ygg was updated, one can delete fragment.xyz,
rerun fragedit.py and visualize fragment.xyz coordinates.</p>
<p>Now that product.ygg file contains good-enough starting coordinates, we can run a geometry optimization to optimize to the product state.</p>
<p>Optimization of product geometry:</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="kn">from</span> <span class="nn">ash</span> <span class="kn">import</span> <span class="o">*</span>

<span class="n">Cluster_product</span><span class="o">=</span><span class="n">Fragment</span><span class="p">(</span><span class="n">fragfile</span><span class="o">=</span><span class="s1">&#39;product.ygg&#39;</span><span class="p">)</span>
<span class="n">Centralmainfrag</span> <span class="o">=</span> <span class="n">read_intlist_from_file</span><span class="p">(</span><span class="s2">&quot;Centralmainfrag&quot;</span><span class="p">)</span>
<span class="nb">print</span><span class="p">(</span><span class="s2">&quot;Centralmainfrag:&quot;</span><span class="p">,</span> <span class="n">Centralmainfrag</span><span class="p">)</span>
<span class="n">Cluster_FF</span><span class="o">=</span><span class="n">MMforcefield_read</span><span class="p">(</span><span class="s1">&#39;Cluster_forcefield.ff&#39;</span><span class="p">)</span>
<span class="n">orcadir</span><span class="o">=</span><span class="s1">&#39;/opt/orca_4.2.1&#39;</span>
<span class="n">orcasimpleinput</span><span class="o">=</span><span class="s2">&quot;! BP86 def2-SVP def2/J Grid5 Finalgrid6 tightscf&quot;</span>
<span class="n">orcablocks</span><span class="o">=</span><span class="s2">&quot;</span><span class="si">%s</span><span class="s2">cf maxiter 200 end&quot;</span>
<span class="n">ORCAQMpart</span> <span class="o">=</span> <span class="n">ORCATheory</span><span class="p">(</span><span class="n">orcadir</span><span class="o">=</span><span class="n">orcadir</span><span class="p">,</span> <span class="n">charge</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">mult</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">orcasimpleinput</span><span class="o">=</span><span class="n">orcasimpleinput</span><span class="p">,</span> <span class="n">orcablocks</span><span class="o">=</span><span class="n">orcablocks</span><span class="p">)</span>
<span class="n">MMpart</span> <span class="o">=</span> <span class="n">NonBondedTheory</span><span class="p">(</span><span class="n">charges</span> <span class="o">=</span> <span class="n">Cluster_product</span><span class="o">.</span><span class="n">atomcharges</span><span class="p">,</span> <span class="n">atomtypes</span><span class="o">=</span><span class="n">Cluster_product</span><span class="o">.</span><span class="n">atomtypes</span><span class="p">,</span> <span class="n">forcefield</span><span class="o">=</span><span class="n">Cluster_FF</span><span class="p">,</span> <span class="n">LJcombrule</span><span class="o">=</span><span class="s1">&#39;geometric&#39;</span><span class="p">)</span>
<span class="n">QMMM_object</span> <span class="o">=</span> <span class="n">QMMMTheory</span><span class="p">(</span><span class="n">fragment</span><span class="o">=</span><span class="n">Cluster_product</span><span class="p">,</span> <span class="n">qm_theory</span><span class="o">=</span><span class="n">ORCAQMpart</span><span class="p">,</span> <span class="n">mm_theory</span><span class="o">=</span><span class="n">MMpart</span><span class="p">,</span>
    <span class="n">qmatoms</span><span class="o">=</span><span class="n">Centralmainfrag</span><span class="p">,</span> <span class="n">charges</span><span class="o">=</span><span class="n">Cluster</span><span class="o">.</span><span class="n">atomcharges</span><span class="p">,</span> <span class="n">embedding</span><span class="o">=</span><span class="s1">&#39;Elstat&#39;</span><span class="p">,</span> <span class="n">nprocs</span><span class="o">=</span><span class="n">numcores</span><span class="p">)</span>

<span class="n">geomeTRICOptimizer</span><span class="p">(</span><span class="n">theory</span><span class="o">=</span><span class="n">QMMM_object</span><span class="p">,</span> <span class="n">fragment</span><span class="o">=</span><span class="n">Cluster_product</span><span class="p">,</span> <span class="n">coordsystem</span><span class="o">=</span><span class="s1">&#39;tric&#39;</span><span class="p">,</span> <span class="n">maxiter</span><span class="o">=</span><span class="mi">170</span><span class="p">,</span> <span class="n">ActiveRegion</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">actatoms</span><span class="o">=</span><span class="n">Centralmainfrag</span> <span class="p">)</span>
</pre></div>
</div>
<p><strong>2. Running NEB-CI job.</strong></p>
<p>Once you have optimized coordinates for the desired reactant and product, we can start a NEB calculation.
While the input for a NEB calculation, basically follows the example in <a class="reference internal" href="job-types.html"><span class="doc">Job Types</span></a>, it is important to specify the active-region for NEB.</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="kn">from</span> <span class="nn">ash</span> <span class="kn">import</span> <span class="o">*</span>
<span class="kn">from</span> <span class="nn">functions_molcrys</span> <span class="kn">import</span> <span class="o">*</span>
<span class="kn">from</span> <span class="nn">molcrys</span> <span class="kn">import</span> <span class="o">*</span>
<span class="kn">import</span> <span class="nn">interface_knarr</span>
<span class="n">settings_ash</span><span class="o">.</span><span class="n">init</span><span class="p">()</span>
<span class="n">numcores</span><span class="o">=</span><span class="mi">8</span>
<span class="c1">#Read in reactant and product file, previously optimized.</span>
<span class="n">Reactant</span><span class="o">=</span><span class="n">Fragment</span><span class="p">(</span><span class="n">fragfile</span><span class="o">=</span><span class="s1">&#39;reactant.ygg&#39;</span><span class="p">)</span>
<span class="n">Product</span><span class="o">=</span><span class="n">Fragment</span><span class="p">(</span><span class="n">fragfile</span><span class="o">=</span><span class="s1">&#39;Cluster_product.ygg&#39;</span><span class="p">)</span>

<span class="c1">#Read in forcefield</span>
<span class="n">Cluster_FF</span><span class="o">=</span><span class="n">MMforcefield_read</span><span class="p">(</span><span class="s1">&#39;Cluster_forcefield.ff&#39;</span><span class="p">)</span>
<span class="c1">#Read in qmatoms list from file qmatoms</span>
<span class="n">Centralmainfrag</span> <span class="o">=</span> <span class="n">read_intlist_from_file</span><span class="p">(</span><span class="s2">&quot;qmatoms&quot;</span><span class="p">)</span>

<span class="c1">#Theory level defined</span>
<span class="n">xtbdir</span><span class="o">=</span><span class="s1">&#39;/opt/xtb-6.2.3/xtb_6.2.3/bin&#39;</span>
<span class="n">xtbmethod</span><span class="o">=</span><span class="s1">&#39;GFN2&#39;</span>
<span class="n">xtbcalc</span> <span class="o">=</span> <span class="n">xTBTheory</span><span class="p">(</span><span class="n">xtbdir</span><span class="o">=</span><span class="n">xtbdir</span><span class="p">,</span> <span class="n">runmode</span><span class="o">=</span><span class="s1">&#39;inputfile&#39;</span><span class="p">,</span> <span class="n">nprocs</span><span class="o">=</span><span class="n">numcores</span><span class="p">,</span> <span class="n">charge</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">mult</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">xtbmethod</span><span class="o">=</span><span class="n">xtbmethod</span><span class="p">)</span>
<span class="n">MMpart</span> <span class="o">=</span> <span class="n">NonBondedTheory</span><span class="p">(</span><span class="n">charges</span> <span class="o">=</span> <span class="n">Reactant</span><span class="o">.</span><span class="n">atomcharges</span><span class="p">,</span> <span class="n">atomtypes</span><span class="o">=</span><span class="n">Reactant</span><span class="o">.</span><span class="n">atomtypes</span><span class="p">,</span> <span class="n">forcefield</span><span class="o">=</span><span class="n">Cluster_FF</span><span class="p">,</span> <span class="n">LJcombrule</span><span class="o">=</span><span class="s1">&#39;geometric&#39;</span><span class="p">)</span>
<span class="n">QMMM_xtb</span> <span class="o">=</span> <span class="n">QMMMTheory</span><span class="p">(</span><span class="n">qm_theory</span><span class="o">=</span><span class="n">xtbcalc</span><span class="p">,</span> <span class="n">mm_theory</span><span class="o">=</span><span class="n">MMpart</span><span class="p">,</span> <span class="n">fragment</span><span class="o">=</span><span class="n">Reactant</span><span class="p">,</span> <span class="n">actatoms</span><span class="o">=</span><span class="n">Centralmainfrag</span><span class="p">,</span>
    <span class="n">qmatoms</span><span class="o">=</span><span class="n">Centralmainfrag</span><span class="p">,</span> <span class="n">charges</span><span class="o">=</span><span class="n">Reactant</span><span class="o">.</span><span class="n">atomcharges</span><span class="p">,</span> <span class="n">embedding</span><span class="o">=</span><span class="s1">&#39;Elstat&#39;</span><span class="p">,</span> <span class="n">nprocs</span><span class="o">=</span><span class="n">numcores</span><span class="p">)</span>

<span class="c1">#NEB-CI job. Final saddlepoint structure stored in new object &quot;Saddlepoint&quot;</span>
<span class="n">Saddlepoint</span> <span class="o">=</span> <span class="n">interface_knarr</span><span class="o">.</span><span class="n">NEB</span><span class="p">(</span><span class="n">reactant</span><span class="o">=</span><span class="n">Reactant</span><span class="p">,</span> <span class="n">product</span><span class="o">=</span><span class="n">Product</span><span class="p">,</span> <span class="n">theory</span><span class="o">=</span><span class="n">QMMM_xtb</span><span class="p">,</span> <span class="n">images</span><span class="o">=</span><span class="mi">10</span><span class="p">,</span> <span class="n">CI</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
    <span class="n">ActiveRegion</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">actatoms</span><span class="o">=</span><span class="n">Centralmainfrag</span><span class="p">)</span>
</pre></div>
</div>
<p>We import interface_knarr and then call interface_knarr.NEB function. It requires the keyword arguments reactant, product, theory at minimum.
Number of images should typically be specified (default is 6) and CI=True (for NEB-CI) or CI=False (for plain NEB).
ActiveRegion keyword should be set to True and actatoms set (typically same as QM-region, can not be larger).
NEB-CI will return a fragment object for the saddlepoint (if saddlepoint optimization succeeds), here it is named as Saddlepoint.</p>
<p><strong>3. Visualizing the minimum energy path and saddlepoint mode.</strong></p>
<p>While the job is running it is convenient to visualize these files (e.g. in Chemcraft or VMD):</p>
<ul class="simple">
<li><p>XYZ-animation file for initial guess path (active-region): knarr_path.xyz</p></li>
<li><p>XYZ-animation file for minimum energy path (active-region): knarr_current.xyz</p></li>
</ul>
<p>Useful files to visualize after convergence  (e.g. in Chemcraft or VMD; VMD recommended for full coordinates):</p>
<ul class="simple">
<li><p>XYZ coordinate file for saddlepoint structure (active-region): knarr_saddle.xyz</p></li>
<li><p>XYZ coordinate file for saddlepoint structure (full-region): Saddlepoint-optimized.xyz</p></li>
<li><p>XYZ-animation file for saddlepoint mode printed as : knarr_mode.xyz</p></li>
<li><p>XYZ-animation file for minimum energy path (active-region): knarr_MEP.xyz</p></li>
<li><p>XYZ-animation file for minimum energy path (full-region): knarr_MEP_FULL.xyz</p></li>
</ul>
<p>Total energies of all images of minimum energy path are found in file: knarr.energy
For a converged CI-NEB job, the highest energy image of the minimum energy path is the energy of the saddlepoint.
It is found in both knarr.energy, outputfile, header line of knarr_saddle.xyz, Saddlepoint-optimized.ygg, Saddlepoint-optimized.xyz</p>
<p>Ash fragment file for saddlepoint (full coordinates):
Saddlepoint-optimized.ygg</p>
<p><strong>4. Confirm saddlepoint via numerical frequencies. See below.</strong></p>
</div>
<div class="section" id="molcrys-numerical-qm-mm-frequencies">
<h2>MOLCRYS: Numerical QM/MM frequencies<a class="headerlink" href="#molcrys-numerical-qm-mm-frequencies" title="Permalink to this headline">¶</a></h2>
<p>Available. Needs to be tested…</p>
</div>
<div class="section" id="molcrys-fragment-identification-connectivity-issues">
<h2>MOLCRYS: Fragment identification/Connectivity issues<a class="headerlink" href="#molcrys-fragment-identification-connectivity-issues" title="Permalink to this headline">¶</a></h2>
<p>If there are difficulties in obtaining the correct fragment identification from the CIF file, first check that the CIF file is correct:</p>
<div class="line-block">
<div class="line">- Are there atoms missing? e.g. hydrogens? These would have to be added to the CIF file.</div>
<div class="line">- Are there multiple thermal populations of some residues? These would have to be deleted from the CIF file</div>
<div class="line">- Do the total atoms in the unit cell add up to the expected number of atoms based on the fragments present?</div>
</div>
<p>If the atoms in the unitcell are correct then the problem is more likely to do with the default connectivity parameters
not being general enough for the system.
Start by playing around with the tol parameter, try values between 0 to 0.5
The scaling parameter can also be used, though often it is less useful.
Often, modifying the covalent radius of an element (see above example for Na+) works well.</p>
<p>The auto_connectivity=True feature should usually work.</p>
</div>
<div class="section" id="molcrys-molecular-dynamics">
<h2>MOLCRYS: Molecular Dynamics<a class="headerlink" href="#molcrys-molecular-dynamics" title="Permalink to this headline">¶</a></h2>
<p>Not yet ready</p>
</div>
</div>


           </div>
           
          </div>
          <footer>
  
    <div class="rst-footer-buttons" role="navigation" aria-label="footer navigation">
      
        <a href="pes.html" class="btn btn-neutral float-right" title="PES: PhotoElectron/PhotoEmission Spectrum" accesskey="n" rel="next">Next <span class="fa fa-arrow-circle-right"></span></a>
      
      
        <a href="QM-MM.html" class="btn btn-neutral float-left" title="QM/MM Theory" accesskey="p" rel="prev"><span class="fa fa-arrow-circle-left"></span> Previous</a>
      
    </div>
  

  <hr/>

  <div role="contentinfo">
    <p>
        &copy; Copyright 2020, Ragnar Bjornsson

    </p>
  </div>
  Built with <a href="http://sphinx-doc.org/">Sphinx</a> using a <a href="https://github.com/rtfd/sphinx_rtd_theme">theme</a> provided by <a href="https://readthedocs.org">Read the Docs</a>. 

</footer>

        </div>
      </div>

    </section>

  </div>
  


  <script type="text/javascript">
      jQuery(function () {
          SphinxRtdTheme.Navigation.enable(true);
      });
  </script>

  
  
    
    <!-- Theme Analytics -->
    <script>
    (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
      (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
      m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
    })(window,document,'script','https://www.google-analytics.com/analytics.js','ga');

    ga('create', 'UA-XXXXXXX-1', 'auto');
    ga('send', 'pageview');
    </script>

    
   

</body>
</html>