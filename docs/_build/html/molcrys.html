

<!DOCTYPE html>
<!--[if IE 8]><html class="no-js lt-ie9" lang="en" > <![endif]-->
<!--[if gt IE 8]><!--> <html class="no-js" lang="en" > <!--<![endif]-->
<head>
  <meta charset="utf-8">
  
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  
  <title>MOLCRYS: Automatic QM/MM for Molecular Crystals &mdash; Yggdrasill 0.1 documentation</title>
  

  
  
  
  

  
  <script type="text/javascript" src="_static/js/modernizr.min.js"></script>
  
    
      <script type="text/javascript" id="documentation_options" data-url_root="./" src="_static/documentation_options.js"></script>
        <script src="_static/jquery.js"></script>
        <script src="_static/underscore.js"></script>
        <script src="_static/doctools.js"></script>
        <script src="_static/language_data.js"></script>
    
    <script type="text/javascript" src="_static/js/theme.js"></script>

    

  
  <link rel="stylesheet" href="_static/css/theme.css" type="text/css" />
  <link rel="stylesheet" href="_static/pygments.css" type="text/css" />
  <link rel="stylesheet" href="_static/my_theme.css" type="text/css" />
    <link rel="index" title="Index" href="genindex.html" />
    <link rel="search" title="Search" href="search.html" />
    <link rel="next" title="Yggdrasill object classes" href="yggdrasill-classes.html" />
    <link rel="prev" title="ORCA Interface" href="orca-interface.html" /> 
</head>

<body class="wy-body-for-nav">

   
  <div class="wy-grid-for-nav">
    
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search"  style="background: white" >
          

          
            <a href="index.html" class="icon icon-home"> Yggdrasill
          

          
            
            <img src="_static/yggdrasill-logo.png" class="logo" alt="Logo"/>
          
          </a>

          
            
            
              <div class="version">
                0.1
              </div>
            
          

          
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>

          
        </div>

        <div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="main navigation">
          
            
            
              
            
            
              <p class="caption"><span class="caption-text">Contents:</span></p>
<ul class="current">
<li class="toctree-l1"><a class="reference internal" href="About.html">About Yggdrasill</a></li>
<li class="toctree-l1"><a class="reference internal" href="setup.html">Setup</a></li>
<li class="toctree-l1"><a class="reference internal" href="basics.html">Basic usage</a></li>
<li class="toctree-l1"><a class="reference internal" href="coordinate-input.html">Coordinates and fragments</a></li>
<li class="toctree-l1"><a class="reference internal" href="job-types.html">Job Types</a></li>
<li class="toctree-l1"><a class="reference internal" href="QM-interfaces.html">QM Interfaces</a></li>
<li class="toctree-l1"><a class="reference internal" href="orca-interface.html">ORCA Interface</a></li>
<li class="toctree-l1 current"><a class="current reference internal" href="#">MOLCRYS: Automatic QM/MM for Molecular Crystals</a><ul>
<li class="toctree-l2"><a class="reference internal" href="#molcrys-example-qm-mm-cluster-setup-from-cif-file">MOLCRYS Example: QM/MM Cluster setup from CIF-file</a></li>
<li class="toctree-l2"><a class="reference internal" href="#molcrys-qm-mm-geometry-optimization">MOLCRYS: QM/MM Geometry optimization</a></li>
<li class="toctree-l2"><a class="reference internal" href="#molcrys-expanded-qm-region-calculation">MOLCRYS: Expanded QM region calculation</a></li>
<li class="toctree-l2"><a class="reference internal" href="#molcrys-property-calculation">MOLCRYS: Property calculation</a></li>
<li class="toctree-l2"><a class="reference internal" href="#molcrys-numerical-qm-mm-frequencies">MOLCRYS: Numerical QM/MM frequencies</a></li>
<li class="toctree-l2"><a class="reference internal" href="#molcrys-molecular-dynamics">MOLCRYS: Molecular Dynamics</a></li>
<li class="toctree-l2"><a class="reference internal" href="#molcrys-fragment-identification-connectivity-issues">MOLCRYS: Fragment identification/Connectivity issues</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="yggdrasill-classes.html">Yggdrasill object classes</a></li>
</ul>

            
          
        </div>
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap">

      
      <nav class="wy-nav-top" aria-label="top navigation">
        
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="index.html">Yggdrasill</a>
        
      </nav>


      <div class="wy-nav-content">
        
        <div class="rst-content">
        
          















<div role="navigation" aria-label="breadcrumbs navigation">

  <ul class="wy-breadcrumbs">
    
      <li><a href="index.html">Docs</a> &raquo;</li>
        
      <li>MOLCRYS: Automatic QM/MM for Molecular Crystals</li>
    
    
      <li class="wy-breadcrumbs-aside">
        
            
            <a href="_sources/molcrys.rst.txt" rel="nofollow"> View page source</a>
          
        
      </li>
    
  </ul>

  
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
            
  <div class="section" id="molcrys-automatic-qm-mm-for-molecular-crystals">
<h1>MOLCRYS: Automatic QM/MM for Molecular Crystals<a class="headerlink" href="#molcrys-automatic-qm-mm-for-molecular-crystals" title="Permalink to this headline">¶</a></h1>
<p>The molecular crystal QM/MM method in Yggdrasill is based on the work described
in articles by Bjornsson et al.[1,2].</p>
<p>The method allows one to easily incorporate solid-state effects into quantum chemical calculations of molecules via an automatic
QM/MM approach for molecular crystals. The protocol reads a crystallographic information file (CIF) directly and proceeds
to build up a spherical cluster of the molecular crystal. By automatic preparation of a nonbonded forcefield for the different
molecular fragments in the crystal and division of the system into a central active QM-region and a frozen MM environment,
a full-fledged forcefield is not required (typically not available for small molecules, especially coordination complexes).
The method then allows one to do electrostatically embedded QM/MM geometry optimizations, electrostically embedded property calculations
(e.g. NMR, EPR, excited state spectra, Mössbauer etc.) and even vibrational spectra via QM/MM numerical frequencies.</p>
<p>Any QM-code that has an interface in Yggdrasill can in principle be used and any QM-method within that code can be used
(analytical gradient strongly recommended for optimizations).</p>
<p>Current limitation: Only ORCA interface is complete at this point.</p>
<a class="reference internal image-reference" href="_images/molcrys-intro-v2a.png"><img alt="_images/molcrys-intro-v2a.png" class="align-center" src="_images/molcrys-intro-v2a.png" style="width: 1200px;" /></a>
<p><strong>The basic protocol is:</strong></p>
<div class="line-block">
<div class="line">1. Read CIF-file (or Vesta XTL-file) containing fractional coordinates of the cell.</div>
<div class="line">2. Apply symmetry operations to get coordinates for whole unit cell</div>
<div class="line">3. Identify the molecular fragments present in cell via connectivity and match with user-input</div>
<div class="line">4. Extend the unit cell and cut out a spherical cluster with user-defined MM radius (typically 30-50 Å). Only whole molecules included.</div>
<div class="line">5. Define atomic charges of the molecular fragments from QM calculations.</div>
<div class="line">6. Define Lennard-Jones parameters of the molecular fragments.</div>
<div class="line">7. Iterate the atomic charges of the main molecular fragment in the center of the cluster (electrostatically embedded QM/MM) until self-concistency.</div>
<div class="line">8a. Optional: Perform QM/MM geometry optimization of the central fragment or other job types.</div>
<div class="line">8b. Optional: Extend the QM-region around the central fragment for improved accuracy.</div>
<div class="line">8c. Optional: Perform numerical frequency calculations or molecular dynamics simulations.</div>
<div class="line">8d. Optional: Molecular property calculation in the solid-state.</div>
</div>
<p><strong>Critical features of the implementation:</strong></p>
<div class="line-block">
<div class="line">- Handles CIF-files with inconsistent atom ordering by automatic fragment reordering.</div>
<div class="line">- Accuracy can be controlled via QM-region expansion (reduces impact of approximate LJ potentials or MM charges).</div>
<div class="line">- Numerical frequencies available (to be tested).</div>
</div>
<p><strong>Limitations:</strong></p>
<div class="line-block">
<div class="line">- CIF file can not contain extra atoms such as multiple thermal populations. Also missing H-atoms have to be added beforehand.</div>
<div class="line">- Polymeric systems or pure solids (e.g. metallic) can not be described. Only system with natural fragmentation.</div>
</div>
<p><strong>Features to be implemented:</strong></p>
<div class="line-block">
<div class="line">- Automatic derivation of Lennard-Jones parameters (only UFF forcefield available at the moment).</div>
<div class="line">- Beyond Lennard-Jones potentials for improved QM-MM interaction.</div>
<div class="line">- Molecular dynamics.</div>
<div class="line">- Polarizable embedding?</div>
</div>
<div class="line-block">
<div class="line">1. Modelling Molecular Crystals by QM/MM: Self-Consistent Electrostatic Embedding for Geometry Optimizations and Molecular Property Calculations in the Solid,  R. Bjornsson and M. Bühl,  J. Chem. Theory Comput., 2012, 8, 498-508.</div>
<div class="line">2. R. Bjornsson, manuscript in preparation</div>
</div>
<div class="section" id="molcrys-example-qm-mm-cluster-setup-from-cif-file">
<h2>MOLCRYS Example: QM/MM Cluster setup from CIF-file<a class="headerlink" href="#molcrys-example-qm-mm-cluster-setup-from-cif-file" title="Permalink to this headline">¶</a></h2>
<p>Here we show how to use the <strong>MOLCRYS</strong> code for an example Na<sup>+</sup> [H<sub>2</sub>PO<sub>4</sub><sup>-</sup> ] crystal. This molecular crystal contains 2 fragment-types:
Na<sup>+</sup> and H<sub>2</sub>PO<sub>4</sub><sup>-</sup> </p>
<a class="reference internal image-reference" href="_images/nah2po4-cell.png"><img alt="_images/nah2po4-cell.png" class="align-center" src="_images/nah2po4-cell.png" style="width: 600px;" /></a>
<p>A Python script should be created and then Yggdrasill  <strong>molcrys</strong> functionality should be imported.</p>
<p>The script should then actually just call one function, called <strong>molcrys</strong> at the bottom of the script:</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="n">Cluster</span> <span class="o">=</span> <span class="n">molcrys</span><span class="p">(</span><span class="n">cif_file</span><span class="o">=</span><span class="n">cif_file</span><span class="p">,</span> <span class="n">fragmentobjects</span><span class="o">=</span><span class="n">fragmentobjects</span><span class="p">,</span> <span class="n">theory</span><span class="o">=</span><span class="n">ORCAcalc</span><span class="p">,</span>
    <span class="n">numcores</span><span class="o">=</span><span class="n">numcores</span><span class="p">,</span> <span class="n">clusterradius</span><span class="o">=</span><span class="n">sphereradius</span><span class="p">,</span> <span class="n">chargemodel</span><span class="o">=</span><span class="n">chargemodel</span><span class="p">,</span> <span class="n">shortrangemodel</span><span class="o">=</span><span class="n">shortrangemodel</span><span class="p">)</span>
</pre></div>
</div>
<p>This is the only function of this script but as we can see, there are a number of arguments to be provided.
It is usually more convenient to define first the necessary variables in multiple lines above this command.
In the full script, seen below, a number of variables are defined, following standard Python syntax.
Yggdrasill-specific functionality is the creation of the ORCAcalc object (instance of the Yggdrasill ORCATheory class),
the creation of mainfrag and counterfrag1 objects (instances of Yggdrasill Fragmenttype class).
The variables are then passed as keyword arguments to the  <strong>molcrys</strong> function at the bottom of the script.</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="kn">from</span> <span class="nn">yggdrasill</span> <span class="kn">import</span> <span class="o">*</span>
<span class="kn">from</span> <span class="nn">molcrys</span> <span class="kn">import</span> <span class="o">*</span>
<span class="n">settings_yggdrasill</span><span class="o">.</span><span class="n">init</span><span class="p">()</span>
<span class="c1">#######################</span>
<span class="c1"># MOLCRYS INPUT          #</span>
<span class="c1">#######################</span>
<span class="n">cif_file</span><span class="o">=</span><span class="s2">&quot;nah2po4_choudhary1981.cif&quot;</span>
<span class="n">sphereradius</span><span class="o">=</span><span class="mi">35</span>

<span class="c1">#Number of cores available for either ORCA parallelization or multiprocessing</span>
<span class="n">numcores</span><span class="o">=</span><span class="mi">12</span>

<span class="c1">#Charge-iteration QMinput</span>
<span class="n">orcadir</span><span class="o">=</span><span class="s1">&#39;/opt/orca_4.2.1&#39;</span>
<span class="n">orcasimpleinput</span><span class="o">=</span><span class="s2">&quot;! BP86 def2-SVP def2/J Grid5 Finalgrid6 tightscf&quot;</span>
<span class="n">orcablocks</span><span class="o">=</span><span class="s2">&quot;</span><span class="si">%s</span><span class="s2">cf maxiter 200 end&quot;</span>
<span class="c1">#Defining QM theory without fragment, charge or mult</span>
<span class="n">ORCAcalc</span> <span class="o">=</span> <span class="n">ORCATheory</span><span class="p">(</span><span class="n">orcadir</span><span class="o">=</span><span class="n">orcadir</span><span class="p">,</span> <span class="n">orcasimpleinput</span><span class="o">=</span><span class="n">orcasimpleinput</span><span class="p">,</span> <span class="n">orcablocks</span><span class="o">=</span><span class="n">orcablocks</span><span class="p">,</span> <span class="n">nprocs</span><span class="o">=</span><span class="n">numcores</span><span class="p">)</span>

<span class="c1">#Chargemodel options: CHELPG, Hirshfeld, CM5, NPA, Mulliken</span>
<span class="n">chargemodel</span><span class="o">=</span><span class="s1">&#39;Hirshfeld&#39;</span>
<span class="c1">#Shortrange model. Usually Lennard-Jones. Options: UFF_all, UFF_modH</span>
<span class="n">shortrangemodel</span><span class="o">=</span><span class="s1">&#39;UFF_modH&#39;</span>

<span class="c1">#Define fragment types in crystal: Descriptive name, formula, charge and mult</span>
<span class="n">mainfrag</span> <span class="o">=</span> <span class="n">Fragmenttype</span><span class="p">(</span><span class="s2">&quot;Phosphate&quot;</span><span class="p">,</span><span class="s2">&quot;PO4H2&quot;</span><span class="p">,</span> <span class="n">charge</span><span class="o">=-</span><span class="mi">1</span><span class="p">,</span><span class="n">mult</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
<span class="n">counterfrag1</span> <span class="o">=</span> <span class="n">Fragmenttype</span><span class="p">(</span><span class="s2">&quot;Sodium&quot;</span><span class="p">,</span><span class="s2">&quot;Na&quot;</span><span class="p">,</span> <span class="n">charge</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span><span class="n">mult</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
<span class="c1">#Define list of fragmentobjects. Passed on to molcrys</span>
<span class="n">fragmentobjects</span><span class="o">=</span><span class="p">[</span><span class="n">mainfrag</span><span class="p">,</span><span class="n">counterfrag1</span><span class="p">]</span>

<span class="c1">#Define global system settings (currently scale and tol keywords for connectivity)</span>
<span class="n">settings_yggdrasill</span><span class="o">.</span><span class="n">scale</span><span class="o">=</span><span class="mf">1.0</span>
<span class="n">settings_yggdrasill</span><span class="o">.</span><span class="n">tol</span><span class="o">=</span><span class="mf">0.3</span>
<span class="c1">#settings_molcrys.tol=0.0001</span>
<span class="c1"># Modified radii to assist with connectivity.</span>
<span class="c1">#Setting radius of Na to almost 0. Na will then not bond</span>
<span class="n">eldict_covrad</span><span class="p">[</span><span class="s1">&#39;Na&#39;</span><span class="p">]</span><span class="o">=</span><span class="mf">0.0001</span>
<span class="c1">#eldict_covrad[&#39;H&#39;]=0.15</span>
<span class="nb">print</span><span class="p">(</span><span class="n">eldict_covrad</span><span class="p">)</span>


<span class="c1">#Calling molcrys function and define Cluster object</span>
<span class="n">Cluster</span> <span class="o">=</span> <span class="n">molcrys</span><span class="p">(</span><span class="n">cif_file</span><span class="o">=</span><span class="n">cif_file</span><span class="p">,</span> <span class="n">fragmentobjects</span><span class="o">=</span><span class="n">fragmentobjects</span><span class="p">,</span> <span class="n">theory</span><span class="o">=</span><span class="n">ORCAcalc</span><span class="p">,</span>
        <span class="n">numcores</span><span class="o">=</span><span class="n">numcores</span><span class="p">,</span> <span class="n">clusterradius</span><span class="o">=</span><span class="n">sphereradius</span><span class="p">,</span> <span class="n">chargemodel</span><span class="o">=</span><span class="n">chargemodel</span><span class="p">,</span> <span class="n">shortrangemodel</span><span class="o">=</span><span class="n">shortrangemodel</span><span class="p">)</span>
</pre></div>
</div>
<p>We point to the CIF file that should be read and define a sphereradius. We also define the number of cores available
(should later match that defined in the jobscript), that both ORCA and Yggdrasill may use in their parallelization.
Next, an ORCA theory object is defined where we set the path to ORCA and define the structure of the inputfile used
when running ORCA calculations.</p>
<p>The chargemodel and shortrangemodel variables are used to define keywords that <strong>molcrys</strong> will recognize.
The chargemodel defines how to derive the pointcharges for the MM cluster for the QM-MM electrostatic interaction. Available chargemodels are: CHELPG, Hirshfeld, CM5, NPA, Mulliken</p>
<p>The shortrangemodel defines the short-range interactions between QM and MM atoms (other than the electrostatic).
Currently, only the UFF Lennard-Jones model is available that uses element-specific parameters (from the Universal Forcefield, UFF) to set up Lennard-Jones potentials between
all atoms. The “UFF_modH” keyword is currently recommended that uses available parameters for all elements except the LJ
parameters for H are set to zero to avoid artificial repulsion for acidic H-atoms.</p>
<p>Next, we have to define the fragments present in the crystal. In the future, this may become more automated.
Thus, we define a fragment, called <em>mainfrag</em>, that is our primary interest. Here, this is the H<sub>2</sub>PO<sub>4</sub><sup>-</sup> anion, while the counterion Na<sup>+</sup> ion is of less interest, here labelled <em>counterfrag1</em>.
This distinction between fragments means that the <em>mainfrag</em> will be at the center of the cluster.
It also means that the charge-iterations are only performed for <em>mainfrag</em>.
For each molecular fragment, we define an object of class Fragmenttype with a name e.g. “Phosphate”,
elemental formula, e.g. “PO4H2”, and define the charge and multiplicity of that fragment.
The elemental formula is crucial as from the formula the total nuclear charge is calculated which is used to identify these
fragments in the molecular crystal. Once the fragments are defined we group them together in the following order as a list
called fragmentobjects:     fragmentobjects=[mainfrag,counterfrag1]</p>
<p>Finally, the script shows how the connectivity can be modified in order for the fragment identification to succeed.
The fragment identification works by finding what atoms are connected according to the formula:</p>
<p>(AtomA,AtomB-distance) &lt; scale*(AtomA-covalent-radius+AtomB-covalent-radius) + tol</p>
<p>Thus, if the distance between atoms A and B is less than the sum of the elemental covalent radii
(which can be scaled by a parameter scale or shifted by a parameter tol) then the atoms are connected.
Using default parameters of the element radii (Alvarez 2008), the default scaling of 1.0 and a tolerance of 0.1
(global scale and tol parameters are defined in settings_yggdrasill file) works in many cases.
For the NaH<sub>2</sub> PO<sub>4</sub> crystal, however, that features strong hydrogen-bonding and the ionic Na<sup>+</sup> fragment, however, we have to make some modifications.
In the script above, we thus have to set the tol parameter to 0.3 and change the radius of the Na<sup>+</sup> ion to a small value.
The covalent radii of the elements are stored in a global Python dictionary, eldict_covrad which can be easily modified as shown
and its contents printed. In the future, the radius of the Na may by default be set to a small number.</p>
<p>Unlike the other variables, the <em>settings_yggdrasill.scale</em>, <em>settings_yggdrasill.tol</em> and <em>eldict_covrad</em> are
global variables (already defined but can be modified) that <strong>molcrys</strong> and <strong>Yggdrasill</strong> will have access to.</p>
<p>The other variables defined in the script have to be passed as keyword argument values to the respective keyword of
the <strong>molcrys</strong> function:</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="n">Cluster</span> <span class="o">=</span> <span class="n">molcrys</span><span class="p">(</span><span class="n">cif_file</span><span class="o">=</span><span class="n">cif_file</span><span class="p">,</span> <span class="n">fragmentobjects</span><span class="o">=</span><span class="n">fragmentobjects</span><span class="p">,</span> <span class="n">theory</span><span class="o">=</span><span class="n">ORCAcalc</span><span class="p">,</span>
    <span class="n">numcores</span><span class="o">=</span><span class="n">numcores</span><span class="p">,</span> <span class="n">clusterradius</span><span class="o">=</span><span class="n">sphereradius</span><span class="p">,</span> <span class="n">chargemodel</span><span class="o">=</span><span class="n">chargemodel</span><span class="p">,</span> <span class="n">shortrangemodel</span><span class="o">=</span><span class="n">shortrangemodel</span><span class="p">)</span>
</pre></div>
</div>
<p>These are currently the only arguments that can be provided to the <strong>molcrys</strong> function, with the exception that
instead of a <em>cif_file</em> argument, an <em>xtl_file</em> argument can alternatively be provided where the name of the XTL-file should
be passed on instead. An XTL-file can be created by the Vesta software (<a class="reference external" href="http://jp-minerals.org/vesta/en/">http://jp-minerals.org/vesta/en/</a>).</p>
<p>The purpose of the molcrys function is primarily to create an Yggdrasill cluster-fragment, here called Cluster. The Cluster fragment
will contain the coordinates of the spherical MM cluster with charges from the self-consistent QM procedure and atom-types
defined via the shortrange model procedure chosen. The Cluster fragment is both present in memory once defined (i.e. the molcrys function has finished)
and is also written to disk as: Cluster.ygg. A forcefield file is also created by <strong>molcrys</strong>: Cluster_forcefield.ff, that contains
the Lennard-Jones parameters defined for the atomtypes that have been chosen for every atom in the Cluster fragment.</p>
<p>Typically running the <strong>molcrys</strong> function takes only a few minutes, depending on the size of the molecular fragments
and the size of the Cluster radius but usually it is easiest to submit this to the cluster to run the QM calculations in parallel.
If the connectivity requires modifications, however, then first running through the script directly (on a local
computer or frontnode of the cluster) may be easier.</p>
<p>The Cluster fragment file, Cluster.ygg, can be used directly in a single-point property job (see later).
If using the ORCA interface, the last orca-input.inp and orca-input.pc files created by <strong>molcrys</strong>
can also directly be used to run a single-point electrostatically-embedded property calculation with ORCA
(note: not a geometry optimization though) as they contain the QM-coordinates of the central fragment (orca-input.inp) and .
the MM coordinates and self-consistent pointcharges (orca-input.pc).</p>
</div>
<div class="section" id="molcrys-qm-mm-geometry-optimization">
<h2>MOLCRYS: QM/MM Geometry optimization<a class="headerlink" href="#molcrys-qm-mm-geometry-optimization" title="Permalink to this headline">¶</a></h2>
<p>To run a QM/MM geometry optimization, this can be done separately by preparing a regular Yggdrasill QM/MM inputfile and read in
the Cluster fragment file and the forcefield file, Cluster_forcefield.ff.
It is often more convenient to continue with a QM/MM geometry optimization in the same script, after the <strong>molcrys</strong> function.
In that case, the code below can simply be appended to the previous script.</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="c1">#Once molcrys is done we have a Cluster object (named Cluster) in memory and also printed to disk as Cluster.ygg</span>
<span class="c1"># We can then do optimization right here using that Cluster object.</span>
<span class="c1">#Alternatively or for restart purposes we can read Cluster object into a separate QM/MM Opt job.</span>
<span class="nb">print</span><span class="p">(</span><span class="s2">&quot;Now Doing Optimization&quot;</span><span class="p">)</span>
<span class="c1"># Defining Centralmainfrag (list of atoms) for optimization</span>
<span class="c1">#Centralmainfrag=fragmentobjects[0].clusterfraglist[0]</span>
<span class="n">Centralmainfrag</span><span class="o">=</span><span class="n">Cluster</span><span class="o">.</span><span class="n">connectivity</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
<span class="c1">#Can also be done manually</span>
<span class="c1">#Centralmainfrag=[0, 1, 5, 8, 9, 12, 14]</span>
<span class="nb">print</span><span class="p">(</span><span class="s2">&quot;Centralmainfrag:&quot;</span><span class="p">,</span> <span class="n">Centralmainfrag</span><span class="p">)</span>

<span class="n">charge</span><span class="o">=</span><span class="n">fragmentobjects</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">Charge</span>
<span class="n">mult</span><span class="o">=</span><span class="n">fragmentobjects</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">Mult</span>
<span class="c1">#</span>
<span class="n">Cluster_FF</span><span class="o">=</span><span class="n">MMforcefield_read</span><span class="p">(</span><span class="s1">&#39;Cluster_forcefield.ff&#39;</span><span class="p">)</span>

<span class="c1">#Defining, QM, MM and QM/MM theory levels for Optimization</span>
<span class="c1">#If same theory as used in molcrys, then orcadir, orcasimpleinput and orcablocks can be commented out/deleted.</span>
<span class="n">orcadir</span><span class="o">=</span><span class="s1">&#39;/opt/orca_4.2.1&#39;</span>
<span class="n">orcasimpleinput</span><span class="o">=</span><span class="s2">&quot;! BP86 def2-SVP def2/J Grid5 Finalgrid6 tightscf&quot;</span>
<span class="n">orcablocks</span><span class="o">=</span><span class="s2">&quot;</span><span class="si">%s</span><span class="s2">cf maxiter 200 end&quot;</span>
<span class="n">ORCAQMpart</span> <span class="o">=</span> <span class="n">ORCATheory</span><span class="p">(</span><span class="n">orcadir</span><span class="o">=</span><span class="n">orcadir</span><span class="p">,</span> <span class="n">charge</span><span class="o">=</span><span class="n">charge</span><span class="p">,</span> <span class="n">mult</span><span class="o">=</span><span class="n">mult</span><span class="p">,</span> <span class="n">orcasimpleinput</span><span class="o">=</span><span class="n">orcasimpleinput</span><span class="p">,</span> <span class="n">orcablocks</span><span class="o">=</span><span class="n">orcablocks</span><span class="p">)</span>
<span class="n">MMpart</span> <span class="o">=</span> <span class="n">NonBondedTheory</span><span class="p">(</span><span class="n">charges</span> <span class="o">=</span> <span class="n">Cluster</span><span class="o">.</span><span class="n">atomcharges</span><span class="p">,</span> <span class="n">atomtypes</span><span class="o">=</span><span class="n">Cluster</span><span class="o">.</span><span class="n">atomtypes</span><span class="p">,</span> <span class="n">forcefield</span><span class="o">=</span><span class="n">Cluster_FF</span><span class="p">,</span> <span class="n">LJcombrule</span><span class="o">=</span><span class="s1">&#39;geometric&#39;</span><span class="p">)</span>
<span class="n">QMMM_object</span> <span class="o">=</span> <span class="n">QMMMTheory</span><span class="p">(</span><span class="n">fragment</span><span class="o">=</span><span class="n">Cluster</span><span class="p">,</span> <span class="n">qm_theory</span><span class="o">=</span><span class="n">ORCAQMpart</span><span class="p">,</span> <span class="n">mm_theory</span><span class="o">=</span><span class="n">MMpart</span><span class="p">,</span>
    <span class="n">qmatoms</span><span class="o">=</span><span class="n">Centralmainfrag</span><span class="p">,</span> <span class="n">atomcharges</span><span class="o">=</span><span class="n">Cluster</span><span class="o">.</span><span class="n">atomcharges</span><span class="p">,</span> <span class="n">embedding</span><span class="o">=</span><span class="s1">&#39;Elstat&#39;</span><span class="p">,</span> <span class="n">nprocs</span><span class="o">=</span><span class="n">numcores</span><span class="p">)</span>


<span class="n">geomeTRICOptimizer</span><span class="p">(</span><span class="n">theory</span><span class="o">=</span><span class="n">QMMM_object</span><span class="p">,</span> <span class="n">fragment</span><span class="o">=</span><span class="n">Cluster</span><span class="p">,</span> <span class="n">coordsystem</span><span class="o">=</span><span class="s1">&#39;tric&#39;</span><span class="p">,</span> <span class="n">maxiter</span><span class="o">=</span><span class="mi">170</span><span class="p">,</span> <span class="n">ActiveRegion</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">actatoms</span><span class="o">=</span><span class="n">Centralmainfrag</span> <span class="p">)</span>
</pre></div>
</div>
<p>We define a variable Centralmainfrag as the list of atoms that should be both described at the QM level (will be passed to qmatoms keyword argument)
and should be optimized in a geometry optimization (will be passed to actatoms of optimizer ). This list may also be a larger QM-cluster, e.g. multiple H2PO4 units or with Na+ included.</p>
<p>The charge and multiplicity of the molecule is then defined and a forcefield object is defined by reading in the ‘Cluster_forcefield.ff’
forcefield file, previously created by the <strong>molcrys</strong> function.</p>
<p>Next we have to define a QM/MM object by combining a QM-theory object (here of class ORCATheory) and an MM theory object (of class NonBondedTheory).
See QM/MM theory page for more information on this.</p>
<p>Finally we call the optimizer program, here the geomeTRICoptimizer:</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="n">geomeTRICOptimizer</span><span class="p">(</span><span class="n">theory</span><span class="o">=</span><span class="n">QMMM_object</span><span class="p">,</span> <span class="n">fragment</span><span class="o">=</span><span class="n">Cluster</span><span class="p">,</span> <span class="n">coordsystem</span><span class="o">=</span><span class="s1">&#39;tric&#39;</span><span class="p">,</span> <span class="n">maxiter</span><span class="o">=</span><span class="mi">170</span><span class="p">,</span> <span class="n">ActiveRegion</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">actatoms</span><span class="o">=</span><span class="n">Centralmainfrag</span> <span class="p">)</span>
</pre></div>
</div>
<p>We provide a theory argument to the optimizer (our QM/MM object), the Cluster fragment, we specify the coordinate
system (here the TRIC internal coordinates are used), max no. of iterations may be provided and finally we specify that we have an active region
and that only the atoms provided to the actatoms keyword argument should be optimized. Note that MM atoms can not be optimized when
doing nonbonded QM/MM like we are doing here.</p>
<p>If the optimization converges, a new fragment containing the optimized geometry is provided, called “Fragment-optimized.ygg”.
Note: Only the geometry of the central fragment (or whatever qmatoms/actoms was set to) is optimized. The other atoms
are still at the original positions as determined from the crystal structure.
The optimization trajectory is also available as a multi-structure XYZ file, as either “geometric_OPTtraj_Full.xyz”
(Full system) or “geometric_OPTtraj.xyz” (Act-region only).</p>
<p><strong>Note:</strong></p>
<p>If the optimization is done separately, the code above would have to be manually changed in a few places.
First the Cluster fragment would be read in:</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="n">Cluster</span><span class="o">=</span><span class="n">Fragment</span><span class="p">(</span><span class="n">fragfile</span><span class="o">=</span><span class="s1">&#39;Cluster.ygg&#39;</span><span class="p">)</span>
</pre></div>
</div>
<p>One would then manually define variables charge, mult (of the main fragment) as <em>fragmentobjects</em> would not be available.</p>
</div>
<div class="section" id="molcrys-expanded-qm-region-calculation">
<h2>MOLCRYS: Expanded QM region calculation<a class="headerlink" href="#molcrys-expanded-qm-region-calculation" title="Permalink to this headline">¶</a></h2>
<p>For either a QM/MM geometry optimization or a QM/MM single-point property calculation (see below), the QM-region does
not have to be a single fragment. If the qmatoms list and the actatoms list (for optimizations) is modified, then a larger
QM cluster can be calculated instead in the QM/MM calculation. This should generally result in a more accurate calculation
as the QM-MM boundary effect can be reduced.</p>
<p>The qmatoms and actatoms lists (i.e. the values provided to qmatoms and actatoms keyword arguments to QM/MM object or
geomeTRICOptimizer function can be modified manually, e.g. by visually inspecting an XYZ-file version of the Cluster and
provide the correct list of atom indices (Note: Yggdrasill counts from zero).</p>
<p>More conveniently, the QMregionfragexpand function can be used to find nearby atoms for an initial list of atoms.</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="n">Centralmainfrag</span><span class="o">=</span><span class="n">Cluster</span><span class="o">.</span><span class="n">connectivity</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
<span class="n">expanded_central_region</span> <span class="o">=</span> <span class="n">QMregionfragexpand</span><span class="p">(</span><span class="n">fragment</span><span class="o">=</span><span class="n">Cluster</span><span class="p">,</span><span class="n">initial_atoms</span><span class="o">=</span><span class="n">Centralmainfrag</span><span class="p">,</span> <span class="n">radius</span><span class="o">=</span><span class="mi">3</span><span class="p">)</span>
</pre></div>
</div>
<p>In the code example above, a new variable called “expanded_central_region” is defined that contains a new list of atoms containing
whole fragments that are 3 Å away from the central mainfrag.
This expanded_central_region list can then be fed to qmatoms and actatoms keyword arguments in either a QM/MM optimization
job or a single-point property job.
The radius variable would have to be tweaked and the result inspected to get appropriately sized and shaped QM-clusters.</p>
<p><strong>Note:</strong> The charge and multiplicity keywords probably need to be changed for the new QM-cluster calculations.</p>
</div>
<div class="section" id="molcrys-property-calculation">
<h2>MOLCRYS: Property calculation<a class="headerlink" href="#molcrys-property-calculation" title="Permalink to this headline">¶</a></h2>
<p>A QM/MM molecular/spectroscopic property calculations can be carried either using Yggdrasill or using the QM program directly.
If using ORCA, the appropriate property keywords can be added to orcasimpleinput or orcablocks variables that will be passed onto ORCA.</p>
<p>A single-point QM/MM calculation can be performed by defining a QM/MM object as done before and then simply use the object’s
internal run function (run performs a single-point energy calculation). Make sure to specify the desired Cluster object: e.g. the original Cluster
from the CIF-file or the Cluster file from the QM/MM optimization (contains optimized coordinates for the central fragment).</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="kn">from</span> <span class="nn">yggdrasill</span> <span class="kn">import</span> <span class="o">*</span>
<span class="n">settings_yggdrasill</span><span class="o">.</span><span class="n">init</span><span class="p">()</span>

<span class="c1">#Read in Cluster fragment</span>
<span class="n">Cluster</span><span class="o">=</span><span class="n">Fragment</span><span class="p">(</span><span class="n">fragfile</span><span class="o">=</span><span class="s1">&#39;Cluster.ygg&#39;</span><span class="p">)</span>

<span class="c1"># Defining Centralmainfrag (list of atoms) for optimization</span>
<span class="n">Centralmainfrag</span><span class="o">=</span><span class="n">Cluster</span><span class="o">.</span><span class="n">connectivity</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
<span class="c1">#Can also be done manually</span>
<span class="c1">#Centralmainfrag=[0, 1, 5, 8, 9, 12, 14]</span>
<span class="nb">print</span><span class="p">(</span><span class="s2">&quot;Centralmainfrag:&quot;</span><span class="p">,</span> <span class="n">Centralmainfrag</span><span class="p">)</span>

<span class="c1">#Can also be done done manually if fragmentobjects not available, e.g. charge=-1, mult=1</span>
<span class="n">charge</span><span class="o">=-</span><span class="mi">1</span>
<span class="n">mult</span><span class="o">=</span><span class="mi">1</span>

<span class="c1">#Reading in force-field file</span>
<span class="n">Cluster_FF</span><span class="o">=</span><span class="n">MMforcefield_read</span><span class="p">(</span><span class="s1">&#39;Cluster_forcefield.ff&#39;</span><span class="p">)</span>

<span class="c1">#Defining, QM, MM and QM/MM theory levels for Optimization</span>
<span class="c1">#ORCAlines: If same theory as used in molcrys, then orcadir, orcasimpleinput and orcablocks can be commented out/deleted.</span>
<span class="n">numcores</span><span class="o">=</span><span class="mi">12</span>
<span class="n">orcadir</span><span class="o">=</span><span class="s1">&#39;/opt/orca_4.2.1&#39;</span>
<span class="n">orcasimpleinput</span><span class="o">=</span><span class="s2">&quot;! PBE0 def2-SVP def2/J Grid5 Finalgrid6 tightscf NMR&quot;</span>
<span class="n">orcablocks</span><span class="o">=</span><span class="s2">&quot;</span>
<span class="o">%</span><span class="n">scf</span> <span class="n">maxiter</span> <span class="mi">200</span> <span class="n">end</span>
<span class="o">%</span><span class="n">eprnmr</span>
<span class="n">Nuclei</span> <span class="o">=</span> <span class="nb">all</span> <span class="n">B</span> <span class="p">{</span> <span class="n">shift</span> <span class="p">}</span>
<span class="n">Nuclei</span> <span class="o">=</span> <span class="nb">all</span> <span class="n">C</span> <span class="p">{</span> <span class="n">shift</span> <span class="p">}</span>
<span class="n">end</span>
<span class="s2">&quot;</span>
<span class="n">ORCAQMpart</span> <span class="o">=</span> <span class="n">ORCATheory</span><span class="p">(</span><span class="n">orcadir</span><span class="o">=</span><span class="n">orcadir</span><span class="p">,</span> <span class="n">charge</span><span class="o">=</span><span class="n">charge</span><span class="p">,</span> <span class="n">mult</span><span class="o">=</span><span class="n">mult</span><span class="p">,</span> <span class="n">orcasimpleinput</span><span class="o">=</span><span class="n">orcasimpleinput</span><span class="p">,</span> <span class="n">orcablocks</span><span class="o">=</span><span class="n">orcablocks</span><span class="p">)</span>
<span class="n">MMpart</span> <span class="o">=</span> <span class="n">NonBondedTheory</span><span class="p">(</span><span class="n">charges</span> <span class="o">=</span> <span class="n">Cluster</span><span class="o">.</span><span class="n">atomcharges</span><span class="p">,</span> <span class="n">atomtypes</span><span class="o">=</span><span class="n">Cluster</span><span class="o">.</span><span class="n">atomtypes</span><span class="p">,</span> <span class="n">forcefield</span><span class="o">=</span><span class="n">Cluster_FF</span><span class="p">,</span> <span class="n">LJcombrule</span><span class="o">=</span><span class="s1">&#39;geometric&#39;</span><span class="p">)</span>
<span class="n">QMMM_object</span> <span class="o">=</span> <span class="n">QMMMTheory</span><span class="p">(</span><span class="n">fragment</span><span class="o">=</span><span class="n">Cluster</span><span class="p">,</span> <span class="n">qm_theory</span><span class="o">=</span><span class="n">ORCAQMpart</span><span class="p">,</span> <span class="n">mm_theory</span><span class="o">=</span><span class="n">MMpart</span><span class="p">,</span>
    <span class="n">qmatoms</span><span class="o">=</span><span class="n">Centralmainfrag</span><span class="p">,</span> <span class="n">atomcharges</span><span class="o">=</span><span class="n">Cluster</span><span class="o">.</span><span class="n">atomcharges</span><span class="p">,</span> <span class="n">embedding</span><span class="o">=</span><span class="s1">&#39;Elstat&#39;</span><span class="p">,</span> <span class="n">nprocs</span><span class="o">=</span><span class="n">numcores</span><span class="p">)</span>

<span class="n">QMMM_object</span><span class="o">.</span><span class="n">run</span><span class="p">()</span>
</pre></div>
</div>
<p>Alternatively (somtimes easier), the last ORCA inputfile (orca-input.pc) and pointcharge file (orca-input.pc) from either <strong>molcrys</strong>
or the optimization can be used to run a single-point property job. If the inputfile came from the optimization job then it contains
optimized QM coordinates and the pointcharge-file should contain the self-consistently determined pointcharges for the full cluster.
Thus a simple modification to the inputfile would be required to run a property job using all functionality available in ORCA.</p>
</div>
<div class="section" id="molcrys-numerical-qm-mm-frequencies">
<h2>MOLCRYS: Numerical QM/MM frequencies<a class="headerlink" href="#molcrys-numerical-qm-mm-frequencies" title="Permalink to this headline">¶</a></h2>
<p>Not yet ready</p>
</div>
<div class="section" id="molcrys-molecular-dynamics">
<h2>MOLCRYS: Molecular Dynamics<a class="headerlink" href="#molcrys-molecular-dynamics" title="Permalink to this headline">¶</a></h2>
<p>Not yet ready</p>
</div>
<div class="section" id="molcrys-fragment-identification-connectivity-issues">
<h2>MOLCRYS: Fragment identification/Connectivity issues<a class="headerlink" href="#molcrys-fragment-identification-connectivity-issues" title="Permalink to this headline">¶</a></h2>
<p>If there are difficulties in obtaining the correct fragment identification from the CIF file, first check that the CIF file is correct:</p>
<div class="line-block">
<div class="line">- Are there atoms missing? e.g. hydrogens? These would have to be added to the CIF file.</div>
<div class="line">- Are there multiple thermal populations of some residues? These would have to be deleted from the CIF file</div>
<div class="line">- Do the total atoms in the unit cell add up to the expected number of atoms based on the fragments present?</div>
</div>
<p>If the atoms in the unitcell are correct then the problem is more likely to do with the default connectivity parameters
not being general enough for the system.
Start by playing around with the tol parameter, try values between 0 to 0.5
The scaling parameter can also be used, though often it is less useful.
Often, modifying the covalent radius of an element (see above example for Na+) works well.</p>
</div>
</div>


           </div>
           
          </div>
          <footer>
  
    <div class="rst-footer-buttons" role="navigation" aria-label="footer navigation">
      
        <a href="yggdrasill-classes.html" class="btn btn-neutral float-right" title="Yggdrasill object classes" accesskey="n" rel="next">Next <span class="fa fa-arrow-circle-right"></span></a>
      
      
        <a href="orca-interface.html" class="btn btn-neutral float-left" title="ORCA Interface" accesskey="p" rel="prev"><span class="fa fa-arrow-circle-left"></span> Previous</a>
      
    </div>
  

  <hr/>

  <div role="contentinfo">
    <p>
        &copy; Copyright 2020, Ragnar Bjornsson

    </p>
  </div>
  Built with <a href="http://sphinx-doc.org/">Sphinx</a> using a <a href="https://github.com/rtfd/sphinx_rtd_theme">theme</a> provided by <a href="https://readthedocs.org">Read the Docs</a>. 

</footer>

        </div>
      </div>

    </section>

  </div>
  


  <script type="text/javascript">
      jQuery(function () {
          SphinxRtdTheme.Navigation.enable(true);
      });
  </script>

  
  
    
    <!-- Theme Analytics -->
    <script>
    (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
      (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
      m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
    })(window,document,'script','https://www.google-analytics.com/analytics.js','ga');

    ga('create', 'UA-XXXXXXX-1', 'auto');
    ga('send', 'pageview');
    </script>

    
   

</body>
</html>